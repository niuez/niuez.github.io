{"/":{"title":"Nuartz","content":"\n# I am...\n\n- [GitHub](https://github.com/niuez)\n- [Twitter](https://twitter.com/xiuez)\n\n# Competitive Programming \n\n- [AtCoder](https://atcoder.jp/users/niuez)\n- [C++ competitive library](https://niuez.github.io/cp-cpp-library/)\n- [Rust competitive library](https://github.com/niuez/cp-rust-library)\n\n# Creation\n\n- [svg\\_vis](https://github.com/niuez/svg_vis) library for visualizer\n- colorschemes\n  - [lyla.vim](https://github.com/niuez/lyla.vim) neovim colorscheme\n  - [gekkou.vim](https://github.com/niuez/gekkou.vim) neovim colorscheme\n    - [vscode-gekkou-theme](https://github.com/niuez/vscode-gekkou-theme) for vscode\n- [nakochan](https://github.com/niuez/nakochan) TTS bot working on discord with coeiroink\n- [Niu Lang](https://github.com/niuez/Niu) Rust like lang to C++\n- [UDON generator](https://github.com/niuez/UDON_generator) joke for Advent Calender\n- ...\n\n# とのこちゃん\n\n- [Gallery](/gallery)\n","lastmodified":"2022-12-31T12:11:22.68462785Z","tags":null},"/gallery/":{"title":"gallery","content":"\n## illust. 球根\n![](/gallery/tonoko.png)\n\n[skebの作品ページ](https://skeb.jp/@usanagi_kon/works/27)\n\n## illust. ゆい\n![](/gallery/tonoko_2.png)\n\n## illust. ゆい\n![](/gallery/tonoko_e.png)\n\n## illust. ゆい\n![](/gallery/tonoko_winter.png)\n","lastmodified":"2022-12-31T12:11:22.68462785Z","tags":null},"/notes/abc051-b":{"title":"ABC051 B Sum of Three IntegersをO(1)","content":"\n今日[maspyさんの形式的べき級数](https://maspypy.com/category/%e5%bd%a2%e5%bc%8f%e7%9a%84%e3%81%b9%e3%81%8d%e7%b4%9a%e6%95%b0%e8%a7%a3%e8%aa%ac)の記事を読んだ後に、サークルの見学会にいったらいきなりバチャが始まって、FPSが使えたのでメモ\n\n[ABC051B](https://atcoder.jp/contests/abc051/tasks/abc051_b) 全探索で$O(K^2)$ですが、これを$O(1)$まで落としましょう。\n\n\nまずは、問題をべき級数に落とし込むところからスタートしましょう。$\\[0, K\\]$から1つ整数を選ぶのは、$1+x+x^2+...x^K$と表せて、3個選んで和をとるのは$(1+x+x^2+...x^K)^3$となって、求めたい答えは$x^S$の係数となります。この式展開を愚直にすれば$O(K^2)$です。\n\n式変形して計算量を改善していきます。等比数列の和から、$(1+x+x^2+...x^K)^3 = \\frac{(1 - x^{K + 1})^3}{(1 - x)^3}$となります。分子は展開して$1 - 3 x^{K + 1} + 3 x^{2 (K + 1)} - x^{3(K + 1)}$となります. $\\frac{1}{1 - x} = 1 + x + x^2 + \\cdots$は累積和の操作にあたるので、3回累積和をとればいいです. これで$O(K)$まで落ちました。わ〜い！\n\n[O(K)提出コード](https://atcoder.jp/contests/abc051/submissions/30929013)\n\n```cpp\nint main() {\n  i64 K, S;\n  cin \u003e\u003e K \u003e\u003e S;\n  K += 1;\n  vector\u003ci64\u003e A(3 * K + 1);\n  A[0] = 1;\n  A[K] = -3;\n  A[K * 2] = 3;\n  A[K * 3] = -1;\n  rep(q,0,3) {\n    rep(i,1,3 * K + 1) {\n      A[i] += A[i - 1];\n    }\n  }\n  cout \u003c\u003c A[S] \u003c\u003c endl;\n}\n```\n\n3回累積和を取る操作はもっと最適化できそうです。$\\frac{1}{(1 - x)^3} = (1 - x)^{-3}$は、負の二項定理を用いて$\\sum\\_{n=0}^{\\infty} \\binom{n+2}{2} x^n$となるので、これと分子を掛け算すれば良いです。Sの大きさに気をつけて場合分けすれば$O(1)$です！わいわい！\n\n[O(1)提出コード](https://atcoder.jp/contests/abc051/submissions/30929197)\n\n```cpp\nint main() {\n  i64 K, S;\n  cin \u003e\u003e K \u003e\u003e S;\n  K += 1;\n  i64 ans = 0;\n  if(S \u003e= 0) {\n    ans += (S + 2) * (S + 1) / 2;\n  }\n  if(S \u003e= K) {\n    i64 n = S - K;\n    ans += (-3) * (n + 2) * (n + 1) / 2;\n  }\n  if(S \u003e= 2 * K) {\n    i64 n = S - 2 * K;\n    ans += (3) * (n + 2) * (n + 1) / 2;\n  }\n  if(S \u003e= 3 * K) {\n    i64 n = S - 3 * K;\n    ans += (-1) * (n + 2) * (n + 1) / 2;\n  }\n  cout \u003c\u003c ans \u003c\u003c endl;\n}\n```\n\n## しめ\n\n最後に導いた$O(1)$の解法は、重複組合せを用いた包除原理の解法と一致してます. FPSを使った求め方もおもしろいね〜\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/abc135-d":{"title":"ABC135 D - Digits Parade","content":"\n[ABC135 D - Digits Parade](https://atcoder.jp/contests/abc135/tasks/abc135_d)\n\n最初に$S$を反転させておきます。\n\n$$\nf\\_{i} =\n\\begin{cases}\nx^{10^i a} \u0026 (S\\_i=a) \\\\\\\\\n\\sum\\_{j=0}^{9} x^{10^i j} \u0026 (S\\_i=?)\n\\end{cases}\n$$\n\nとすれば、$\\prod_{i = 1}^{N} f\\_i$を$x^{13}=1$としたときの$x^5$の係数が答えになります。毎回周期13で集約すれば、$O(13^2 |S|)$です。\n\n[提出コード](https://atcoder.jp/contests/abc135/submissions/30922848)\n\n```cpp\nstring S;\ncin \u003e\u003e S;\nreverse(all(S));\ni64 N = S.size();\nvector\u003cfp\u003e dp(13);\ndp[0] = 1;\ni64 ten = 1;\nrep(i,0,N) {\n  vector\u003cfp\u003e nxt(13);\n  if(S[i] == '?') {\n    rep(j,0,13) {\n      rep(k,0,10) {\n        nxt[(j + k * ten) % 13] += dp[j];\n      }\n    }\n  }\n  else {\n    i64 k = S[i] - '0';\n    rep(j,0,13) {\n      nxt[(j + k * ten) % 13] += dp[j];\n    }\n  }\n  ten *= 10;\n  ten %= 13;\n  swap(nxt, dp);\n}\ncout \u003c\u003c dp[5] \u003c\u003c endl;\n```\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/abc155-f":{"title":"ABC155 F Perils in ParallelをF_2の行列で解く","content":"\n[ABC155-F Perils in Parallel - kotatsugameの日記](https://kotatsugame.hatenablog.com/entry/2020/02/19/031012)を読んだときのメモです.\n\n[AtCoder F - Perils in Parallel](https://atcoder.jp/contests/abc155/tasks/abc155_f)を$\\mathbb{F}_2$上の行列として考えて解きます. **以下この問題のネタバレを含みます**\n\n## 問題を簡単にする\n\n- 座標$i \\  (0 \\le i \\le N)$のスイッチの状態が$B_i$\n- $i \\ (0 \\le i \\le M)$のコードは$\\[L_i, R_i) \\ (0 \\le L_i, R_i \\le N)$の範囲のスイッチのオンオフを切り替える.\n\nとします.\n\n## $L, R$を行列で表示\n\n気持ちとしては,\n\n```\n(コードを表した行列) * (コードを切ったか切っていないか) = (爆弾のスイッチを切り替えるか切り替えないか)\n```\n\nとすると嬉しい. なので, \n\n$(N, M)$型行列$A$ * $(M, 1)$型行列$\\vec{x}$ $=$ $(N, 1)$型行列$B$ という感じに.\n\nサンプル1で試してみます.\n\n```txt\n3 4\n5 1\n10 1\n8 0\n1 10\n4 5\n6 7\n8 9\n```\n\n$$\nB = \\left(\n  \\begin{array}{c}\n    1 \\\\\n    0 \\\\\n    1\n  \\end{array}\n\\right)\n$$\n\n$$\nA = \\left(\n  \\begin{array}{ccc}\n    1 \u0026 1 \u0026 0 \u0026 0 \\\\\n    1 \u0026 0 \u0026 0 \u0026 0 \\\\\n    1 \u0026 0 \u0026 0 \u0026 1\n  \\end{array}\n\\right)\n$$\n\n$A$は, 「どこの爆弾のスイッチを切り替えるか」を縦に並べて, それを横にくっつけた感じです.\n\n答えとなる$\\vec{x}$は,\n\n$$\n\\vec{x} = \\left(\n  \\begin{array}{c}\n    1 \\\\\n    0 \\\\\n    0 \\\\\n    1\n  \\end{array}\n\\right)\n$$\n\nとなります.\n\n## 求め方\n\n$A \\vec{x} = B$を解くわけなんですが, このままだと解きにくいので行列の基本変形をすることで, $A$を下三角行列に変換します. [行列の基本変形](https://ja.wikipedia.org/wiki/%E8%A1%8C%E5%88%97%E3%81%AE%E5%9F%BA%E6%9C%AC%E5%A4%89%E5%BD%A2)\n\n普通, 連立方程式を解く時は行の基本変形を行います. しかし, 掃き出し法は計算に時間がかかります. ここでは, 列の基本変形をすることで計算量が落ちることを使います. この証明は後にします.\n\n$A$に基本行列$P\\_1 P\\_2 \\cdots P\\_k$を右から掛けて(列の基本変形なので)$A'$と下三角行列に変形したとします. $A' \\vec{x'} = B$を解くのは簡単です. \n\n$\\vec{x'}$から$\\vec{x}$を求めることを考えます. \n\n$$ \\begin{aligned}\nA' \\vec{x'} \u0026= B \\\\\\\\\nA P\\_1 P\\_2 \\cdots P\\_k \\vec{x'} \u0026= A \\vec{x} \\\\\\\\\nP\\_1 P\\_2 \\cdots P\\_k \\vec{x'} \u0026= \\vec{x} \\\\\\\\\n\\end{aligned} $$\n\nとなるので, $\\vec{x'}$を$P\\_k$から行の基本変形していけば$\\vec{x}$が求まります.\n\n## 列の基本変形による計算量削減\n\n縦方向には, $1$が連続していることを使えば, 計算量が削減できます.\n\n同じ始点$L$を持つ区間, $\\[L, R\\_1), \\[L, R\\_2), \\cdots, \\[L, R\\_n)$を$\\[L, R\\_1), \\[R\\_1, R\\_2), \\cdots, \\[R\\_{n-1}, R\\_n)$と掃き出します. すると, 以下のように計算量が計算できます.\n\n掃き出したときに区間が半分未満(ちょうど半分になっていく)になるとすると, $O(\\log N)$回しか処理されません. また, スイッチは$M$個なので$O(M \\log N)$です.  \n区間が半分以上になるのは各$L \\ (0 \\le L \u003c N)$について$O(\\log N)$個しか無いので$O(N \\log N)$です.  \n合わせて$O((N+M) \\log N)$です.  \n吐き出す前にソートが必要なので$O((N + M) \\log (N) \\log ((N + M) \\log N))$です.\n\n## コード\n\n[提出 #10248008 - AtCoder Beginner Contest 155](https://atcoder.jp/contests/abc155/submissions/10248008)\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) \u003c (e);(i)++)\n#define all(x) x.begin(),x.end()\n\n\nint main() {\n  i64 N, M;\n  cin \u003e\u003e N \u003e\u003e M;\n  vector\u003cpair\u003ci64, i64\u003e\u003e vec;\n  rep(i,0,N) {\n    i64 a, b;\n    cin \u003e\u003e a \u003e\u003e b;\n    vec.push_back({ a, b });\n  }\n  vector\u003ci64\u003e A(N), B(N);\n  sort(all(vec));\n  rep(i,0,N) {\n    A[i] = vec[i].first;\n    B[i] = vec[i].second;\n  }\n  vector\u003ci64\u003e L(M), R(M);\n  rep(i,0,M) {\n    i64 l, r;\n    cin \u003e\u003e l \u003e\u003e r;\n    L[i] = lower_bound(all(A), l) - begin(A);\n    R[i] = upper_bound(all(A), r) - begin(A);\n  }\n  vector\u003cvector\u003cpair\u003ci64, i64\u003e\u003e\u003e mat(N);\n  rep(i,0,M) {\n    if(L[i] \u003c R[i]) {\n      mat[L[i]].push_back({ R[i], i });\n    }\n  }\n  vector\u003cpair\u003ci64, i64\u003e\u003e P;\n  rep(i,0,N) {\n    if(mat[i].size() == 0) continue;\n    sort(all(mat[i]));\n    for(i64 j = mat[i].size(); j --\u003e 1;) {\n      int nl = mat[i][j - 1].first;\n      int nr = mat[i][j].first;\n      if(nl \u003c nr) {\n        mat[nl].push_back({ nr, mat[i][j].second });\n        P.push_back({ mat[i][j - 1].second, mat[i][j].second });\n      }\n    }\n  }\n  reverse(all(P));\n  vector\u003ci64\u003e sum(N + 1, 0);\n  vector\u003ci64\u003e ans(M);\n  rep(i,0,N) {\n    if((B[i] + sum[i]) % 2 == 1) {\n      if(mat[i].size() == 0) {\n        cout \u003c\u003c -1 \u003c\u003c endl;\n        return 0;\n      }\n      i64 r = mat[i].front().first;\n      i64 idx = mat[i].front().second;\n      ans[idx] = true;\n      sum[i]++;\n      sum[r]--;\n    }\n    sum[i + 1] += sum[i];\n  }\n  for(auto p: P) {\n    ans[p.first] ^= ans[p.second];\n  }\n  vector\u003ci64\u003e res;\n  rep(i,0,M) {\n    if(ans[i]) res.push_back(i);\n  }\n  cout \u003c\u003c res.size() \u003c\u003c endl;\n  rep(i,0,res.size()) {\n    cout \u003c\u003c res[i] + 1 \u003c\u003c \" \\n\"[i + 1 == res.size()];\n  }\n}\n```\n\n## 〆\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/arc028-d":{"title":"ARC028 D - 注文の多い高橋商店","content":"\n[ARC028 D - 注文の多い高橋商店](https://atcoder.jp/contests/arc028/tasks/arc028_4)\n\nまず、クエリを無視して計算をします。このときのFPSを$F$とおくと、\n\n$$\n\\begin{aligned}\nF \u0026= \\prod\\_{i = 1}^{N} (1 + \\cdots + x^{a\\_i}) \\\\\\\\\n\u0026= \\prod\\_{i = 1}^{N} \\frac{1 - x^{a\\_i + 1}}{1 - x} \\\\\\\\\n\u0026= (1 - x)^{-N} \\prod\\_{i = 1}^{N} (1 - x^{a\\_i + 1})\n\\end{aligned}\n$$\n\n[EDPC M - Candies](./edpc-m/)と同じ式となり$O(NM)$で計算できます。\n\n次に、$k$種類目の商品を抜いて計算することを考える。$k$種類目の商品を抜いた時のFPSを$G\\_k$とすれば、\n\n$$\n\\begin{aligned}\nG\\_k \u0026= F \\frac{1 - x}{1 - x^{a\\_k + 1}} \\\\\\\\\n     \u0026= F (1 + x^{a\\_k + 1} + x^{2(a\\_k + 1)} + \\cdots) (1 - x)\n\\end{aligned}\n$$\n\n$1 + x^{a\\_k + 1} + x^{2(a\\_k + 1)} + \\cdots$は周期$a\\_k + 1$ごとに累積和を取る操作なので、$G\\_k$は$O(K)$で求められます。\n\nクエリ$k, x$に対しては$[x^{M - x}]G\\_k$で答えることができて、全体で$O(NK)$で求められます。\n\n[提出コード](https://atcoder.jp/contests/arc028/submissions/30922608)\n\n```cpp\ni64 N, K, Q;\ncin \u003e\u003e N \u003e\u003e K \u003e\u003e Q;\nvector\u003ci64\u003e A(N);\nrep(i,0,N) {\n  cin \u003e\u003e A[i];\n  A[i]++;\n}\n\nvector\u003ci64\u003e R(Q), C(Q);\nrep(i,0,Q) cin \u003e\u003e R[i] \u003e\u003e C[i];\nvector\u003cfp\u003e dp(K + 1);\ndp[0] = 1;\nrep(i,0,N) {\n  for(i64 j = K + 1; j --\u003e A[i];) {\n    dp[j] -= dp[j - A[i]];\n  }\n}\nrep(i,0,N) {\n  rep(j,1,K + 1) {\n    dp[j] += dp[j - 1];\n  }\n}\nvector\u003cvector\u003cpair\u003ci64, i64\u003e\u003e\u003e qry(N);\nrep(i,0,Q) {\n  R[i]--;\n  qry[R[i]].push_back( { C[i], i } );\n}\n\nvector\u003cfp\u003e ans(Q);\n\nrep(r,0,N) {\n  vector\u003cfp\u003e nxt(K + 1);\n  vector\u003cfp\u003e sum(A[r]);\n  rep(i,0,K + 1) {\n    sum[i % A[r]] += dp[i];\n    nxt[i] = sum[i % A[r]];\n  }\n  for(i64 j = K + 1; j --\u003e 1;) {\n    nxt[j] -= nxt[j - 1];\n  }\n  for(auto [c, q]: qry[r]) {\n    ans[q] = nxt[K - c];\n  }\n}\nrep(i,0,Q) {\n  cout \u003c\u003c ans[i] \u003c\u003c \"\\n\";\n}\n```\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/buro_ubersicht":{"title":"ブロウちゃんをデスクトップにわいわいさせる(moviepy, ffmpeg, Übersicht)","content":"\n[弊高専アドカレ](https://qiita.com/advent-calendar/2021/snct)埋めます\n\n## 背景\n\nSteamのセールでMuse Dash買いました. ブロウちゃん(アイドル)かわいすぎるなということで, ブロウちゃんをデスクトップでいつでも見れるようにしよう, という企画です.\n\n元素材はキャラ選択画面だとUIが被って見切れるのでYoutubeから拾ってきた.\n\n## 透過\n\nmoviepyでframeに分割していい感じにフィルタ処理, アルファチャンネルを追加してpngに叩き込む.\n\n```py\nfrom moviepy.editor import *\nimport numpy as np\nimport cv2\n\nclip = VideoFileClip(\"idle.mp4\")\n\nloop_clip = VideoFileClip(\"idolloop.mp4\")\nloop_frames = loop_clip.iter_frames()\nmax_cnt = 0\nfor frame in loop_frames:\n    max_cnt += 1\nprint(max_cnt)\n\nclip = clip.subclip(2.0, 6.0)\nprint(clip.fps)\nframes = clip.iter_frames()\n\nnew_frames = []\ncnt = 0\nfor frame in frames:\n    f = np.array(frame)\n    #fb = [tuple(a) for a in f[:,1800,:]]\n    # f = np.where(f == [93, 0, 82], [0, 0, 255], f)\n    fil = np.sum(np.abs(f - [93, 0, 82]), axis=2) \u003c 11\n    (h, w, _) = f.shape\n    res = np.zeros((h, w, 4))\n    # BGR \u003c- RGB\n    res[:,:,2] = np.where(fil, 0, f[:,:,0])\n    res[:,:,1] = np.where(fil, 0, f[:,:,1])\n    res[:,:,0] = np.where(fil, 0, f[:,:,2])\n    res[:,:,3] = np.where(fil, 0, 255)\n    print(cnt)\n    cv2.imwrite(\"%03d_idle.png\" % cnt, res)\n    cnt = cnt + 1\n    if cnt == max_cnt:\n        break\n    #ff = [tuple(a) for a in f[:,1880,:]]\n```\n\n## 透過動画\n\n[How to use transparent videos on the web in 2021](https://rotato.app/blog/transparent-videos-for-the-web)によると, \n\n- ChromeではVP9コーディックのwebm形式\n- SafariではHEVCコーディックのmov形式\n\nなら透過動画が扱えるらしい. ffmpegを使ってpngの列をwebm, movに変換してみる.\n\n### Chrome\n\nこっちは簡単, コーディックに`libvpx-vp9`を指定すればOK\n\n```\nffmpeg -framerate 60 -f image2 -i %03d_idle.png -c:v libvpx-vp9 output.webm\n```\n\n### Safari\n\nこっちがマジで面倒臭い. コーディックに`hevc`を指定するとデフォルトでは`libx265`が選択される. 詳細を`ffmpeg -h encoder=hevc`で表示すると\n```\n    Supported pixel formats: yuv420p yuvj420p yuv422p yuvj422p yuv444p yuvj444p gbrp yuv420p10le yuv422p10le yuv444p10le gbrp10le yuv420p12le yuv422p12le yuv444p12le gbrp12le gray gray10le gray121e\n```\n\n`yuva`のような`a`が含まれていないとアルファチャンネルを加味してエンコードしてくれないらしい.\n\n`hevc_videotoolbox`を用いれば`bgra`が含まれていてOK\n\n```\nffmpeg -framerate 60 -i %03d_idle.png -c:v hevc_videotoolbox -allow_sw 1 -alpha_quality 1 -tag:v hvc1 output.mov\n```\n\n## Übersicht\n\n[Übersicht](http://tracesof.net/uebersicht/). これすごい. Reactの要素とか投げられる.\n\n[paulbhartzog/ubersicht-video-widget](https://github.com/paulbhartzog/ubersicht-video-widget)を参考にして, 動画を再生させる. 以下のcoffee scriptをWidget Folderに含めると動く. output.movは, Widget Folderに含めればOK.\n\n```coffee\nrefreshFrequency: false\n\nrender: -\u003e\"\"\"\n  \u003cvideo width=\"240\" loop autoplay playsinline\u003e\n    \u003csource src=\"output.mov\" type=\"video/mp4\"\u003e\n    Your browser does not support the video tag.\n  \u003c/video\u003e\n\"\"\"\n\nstyle: \"\"\"\n  top: calc(100% - 135px)\n  left: calc(50% - 110px)\n  border: 0px solid #fff\n  z-index: 1000\n  background-color: rgba(255, 255, 255, 0)\n  /* kluge to erase space at bottom of video inside container */\n  video\n    margin-bottom: 0px\n\"\"\"\n```\n\n## 動いてる感じ\n\n\u003cblockquote class=\"twitter-tweet\"\u003e\u003cp lang=\"ja\" dir=\"ltr\"\u003eMuseDashのブロウちゃんわいわいさせてたら時間溶けてた \u003ca href=\"https://t.co/oA7ny2iAp9\"\u003epic.twitter.com/oA7ny2iAp9\u003c/a\u003e\u003c/p\u003e\u0026mdash; Niuez (@xiuez) \u003ca href=\"https://twitter.com/xiuez/status/1475104564651368448?ref_src=twsrc%5Etfw\"\u003eDecember 26, 2021\u003c/a\u003e\u003c/blockquote\u003e \u003cscript async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"\u003e\u003c/script\u003e\n\n## 〆\n\nかわいい\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/dfs_bfs_et":{"title":"DFS+BFS Numberingで部分木の任意深さのクエリを処理する","content":"\nTree Depth Query by BFS Numberingについては[Tree Depth Query by BFS Numbering - niuez.github.io](https://niuez.github.io/posts/entry/2019/10/05/002503/)を参照してください.\n\n## 処理したいクエリ (例)\n\n有向木が与えられ, 各頂点には重みがある.\n\n- 頂点$v$から, 辺をちょうど$d$個たどって到達できる頂点の重みの総和を出力\n\n総和じゃなくても更新とかもしたいよね.\n\n## アルゴリズム\n\nBFS Numberingをすると, 同じ深さの頂点が並ぶということは上の記事をみるとわかります. これにDFS Euler Tourしたときの情報を合わせることで任意深さについで, BFS Euler Tourしたときの区間を前計算$O(N)$, クエリ$O(\\log N)$で求めることができます.\n\n![がぞう](/images/bfs_dfs.png)\n\nBFS Numberingしたときの順番と, DFS Numberingしたときの$in/out$を各ノードに添えました. ただし, **ノードの子供を探索する順序はDFS, BFS共に同じにします**, すると, \n\n- 深さ$0$のノードのbfsの番号と$in$\n\n```\nbfs: 0\nin : 0\n```\n\n- 深さ$1$のノードのbfsの番号と$in$\n\n```\nbfs: 1 2\nin : 1 8\n```\n\n- 深さ$2$のノードのbfsの番号と$in$\n\n```\nbfs: 3 4 5 6\nin : 2 5 9 12\n```\n\n- 深さ$3$のノードのbfsの番号と$in$\n\n```\nbfs: 7 8 9 10 11 12 13 14\nin : 3 4 6 7  10 11 13 14\n```\n\nとなり, 単調増加します.  \nまた, DFS Numberingでは, ある頂点$v$の$[in, out)$は, $v$を根とする部分木に含まれる頂点の$in$の集合です. これを活かして, 頂点$1$から深さ$2$の頂点のBFS Numberingの区間を求めてみます.\n\n木全体での頂点$1$の深さは$1$なので, 求めたい区間の頂点は深さ$3$です.  \nまた, 頂点$1$の$[in, out)$は$[1, 8)$です. なので求めたい頂点の$in$の値は, 深さ$3$での$in$の列の中で$[1, 8)$に含まれている$in = 3, 4, 6, 7$です.  \nこれは, BFS Numberingの区間では$[7, 10)$に相当します.  \n\nこの操作は二分探索で行うことができるので, クエリあたり$O(\\log N)$です.\n\n## 実装\n\n- `para[i] := BFS Numberingでi番目の頂点`\n- `inv_para[v] := BFS Numberingにおける頂点vのインデックス`\n\n```cpp\nstruct bfs_euler_tour {\n  int N;\n  std::vector\u003cstd::vector\u003cint\u003e\u003e G;\n  std::vector\u003cint\u003e in;\n  std::vector\u003cint\u003e out;\n  std::vector\u003cint\u003e para;\n  std::vector\u003cint\u003e inv_para;\n  std::vector\u003cint\u003e dep;\n  std::vector\u003cint\u003e par;\n  std::vector\u003cint\u003e start;\n  int cnt;\n  int D;\n\n  bfs_euler_tour(int N): N(N), G(N), in(N), out(N), para(N, -1), inv_para(N, -1), dep(N), par(N) {}\n\n  void add_edge(int a, int b) {\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  void dfs(int v, int f, int depth) {\n    D = std::max(D, depth);\n    par[v] = f;\n    dep[v] = depth;\n    in[v] = cnt++;\n    for(auto t: G[v]) {\n      if(t == f) continue;\n      dfs(t, v, depth + 1);\n    }\n    out[v] = cnt;\n  }\n\n  void build(int r) {\n    cnt = 0;\n    D = 0;\n    dfs(r, -1, 0);\n    D++;\n\n    cnt = 0;\n    std::vector\u003cint\u003e que(N);\n    int ql = 0;\n    int qr = 0;\n    que[qr++] = r;\n    start.resize(D + 1);\n\n    for(int d = 0; ql \u003c qr; d++) {\n      int r = qr;\n      start[d] = cnt;\n      while(ql \u003c r) {\n        int v = que[ql++];\n        inv_para[v] = cnt;\n        para[cnt++] = v;\n        for(auto t: G[v]) {\n          if(in[v] \u003c in[t]) {\n            que[qr++] = t;\n          }\n        }\n      }\n    }\n    start[D] = cnt;\n  }\n\n  int para_lower_bound(int l, int r, int i) {\n    while(r - l \u003e 1) {\n      int m = (l + r) \u003e\u003e 1;\n      if(i \u003c= in[para[m]]) {\n        r = m;\n      }\n      else {\n        l = m;\n      }\n    }\n    return r;\n  }\n\n  std::pair\u003cint, int\u003e range(int v, int d) {\n    if(dep[v] + d \u003c D) {\n      int l = start[dep[v] + d];\n      int r = start[dep[v] + d + 1];\n      return { para_lower_bound(l - 1, r, in[v]), para_lower_bound(l - 1, r, out[v]) };\n    }\n    else {\n      return { 0, 0 };\n    }\n  }\n};\n```\n\n## 使用例\n\nNo.899 γathereeを解いてみました. [#448690 (C++14) No.899 γatheree - yukicoder](https://yukicoder.me/submissions/448690)\n\n## verify問題\n\nびーと, ありがとう\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/divisor_transform2":{"title":"約数ゼータ・メビウス変換のメモ","content":"\n[以前僕が書いた記事]({{\u003c ref \"notes/divisor_transform_memo\"\u003e}})を復習するときにとても読みにくかったので、もう一度書き直します。\n\n[倍数ゼータ・メビウス変換]({{\u003cref \"notes/multiple_transform\"\u003e}})についても書いたので、合わせて読むといいかも。同じ問題を別視点で考えてます。\n\n## 約数ゼータ・メビウス変換\n\n関数$f(n)$に対する約数ゼータ変換は以下の定義です。$d|n$は「$d$は$n$の約数」という意味です(dはdivisorのd)。約数の足し合わせですね。\n\n$$\nF(n) = \\sum\\_{ d | n } f(d)\n$$\n\n\n約数メビウス変換は、約数ゼータ変換の逆向きの操作です。つまり、$F(n)$から$f(n)$を求める操作です。\n\nちなみに、メビウス変換はメビウスの反転公式から[メビウス関数](https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%93%E3%82%A6%E3%82%B9%E9%96%A2%E6%95%B0)を$\\mu(n)$とすれば、\n\n$$\nf(n) = \\sum\\_{d | n} F(d) \\mu(\\frac{n}{d})\n$$\n\nです。メビウス関数については蟻本にも書いてあります。\n\n## 約数ゼータ・メビウス変換の実装\n\n[高速ゼータ変換の約数版 O(N log(log(N))) - noshi91のメモ](https://noshi91.hatenablog.com/entry/2018/12/27/121649)がはやいです！\n\n## gcdの関係\n\nある$n, m$について、$F(\\gcd(n, m))$を考えてみます。$f$は$F$をメビウス変換した関数です。\n\n$$\nF(\\gcd(n, m)) = \\sum\\_{d | gcd(n, m)} f(d) = \\sum\\_{d | n, d | m} f(d)\n$$\n\n最後の$\\sum$の条件が2つあるので、これをどうにか$d | n$だけにしてみます。\n\n$$\nc(d) =\n\\begin{cases}\n1 \u0026 d | m \\\\\\\\\n0 \u0026 \\text{otherwise}\n\\end{cases}\n$$\n\nとすれば以下のようになります。\n\n$$\nF(\\gcd(n, m)) = \\sum\\_{d | n} f(d) c(d)\n$$\n\nこうすると例えば、$\\sum\\_i F(\\gcd(n, m\\_i))$の計算は\n\n$$\n\\sum\\_i F(\\gcd(n, m\\_i)) = \\sum\\_{d | n} f(d) (\\sum\\_i c\\_i(d))\n$$\n\nとまとめて計算できます。\n\n## AGC038 C - LCMs\n\n[AGC038 C - LCMs](https://atcoder.jp/contests/agc038/tasks/agc038_c)\n\n$$ \n\\begin{align}\n\u0026 \\sum\\_{i = 0}^{N - 1} \\sum\\_{j = 0}^{i - 1} \\operatorname{lcm}(A\\_i, A\\_j) \\\\\\\\\n= \u0026 \\sum\\_{i = 0}^{N - 1} \\sum\\_{j = 0}^{i - 1} A\\_i \\frac{A\\_j}{\\gcd(A\\_i, A\\_j)} \\\\\\\\\n\\end{align}\n$$\n\n$F(n) = \\frac{1}{n}$として、その約数メビウス変換を$f(n)$としましょう。すると、\n\n$$ \n\\begin{align}\n= \u0026 \\sum\\_{i = 0}^{N - 1} A\\_i \\sum\\_{j = 0}^{i - 1} F(\\gcd(A\\_i, A\\_j)) A\\_j \\\\\\\\\n= \u0026 \\sum\\_{i = 0}^{N - 1} A\\_i \\sum\\_{j = 0}^{i - 1} (\\sum\\_{d | \\gcd(A\\_i, A\\_j)} f(d) A\\_j) \\\\\\\\\n= \u0026 \\sum\\_{i = 0}^{N - 1} A\\_i \\sum\\_{j = 0}^{i - 1} (\\sum\\_{d | A\\_i, d | A\\_j} f(d) A\\_j) \\\\\\\\\n\\end{align}\n$$\n\nここで、上の$c(d)$のような係数テクを導入します。\n\n$$\ns\\_j(d) =\n\\begin{cases}\nA\\_j \u0026 d | A\\_j \\\\\\\\\n0 \u0026 \\text{otherwise}\n\\end{cases}\n$$\n\nとすれば、$d | A\\_j$の条件を取り除けて\n\n$$ \n\\begin{align}\n= \u0026 \\sum\\_{i = 0}^{N - 1} A\\_i \\sum\\_{j = 0}^{i - 1} (\\sum\\_{d | A\\_i} f(d) s\\_j(d)) \\\\\\\\\n= \u0026 \\sum\\_{i = 0}^{N - 1} A\\_i \\sum\\_{d | A\\_i} f(d) (\\sum\\_{j = 0}^{i - 1} s\\_j(d)) \\\\\\\\\n\\end{align}\n$$\n\n$\\sum\\_{j = 0}^{i - 1} s\\_j(d)$は$i$を進めながら更新できます。計算量は、$f$を求める約数メビウス変換が$O(A \\log\\log A)$、約数の数は$O(\\sqrt A)$で抑えられるので、全体で$O(A \\log\\log A + N \\sqrt A)$です。\n\n[提出コード](https://atcoder.jp/contests/agc038/submissions/31070938)\n\n```cpp\nconst i64 MAX = 1e6 + 1;\n \nint main() {\n  i64 N;\n  cin \u003e\u003e N;\n  vector\u003ci64\u003e A(N);\n  rep(i,0,N) cin \u003e\u003e A[i];\n \n  vector\u003cfp\u003e f(MAX);\n  rep(i,1,MAX) {\n    f[i] = fp(i).inv();\n  }\n  inverse_divisor_transform(f);\n  \n  vector\u003cfp\u003e sum(MAX);\n  fp ans;\n  for(auto a: A) {\n    fp res;\n    for(i64 d = 1; d * d \u003c= a; d++) {\n      if(a % d == 0) {\n        res += f[d] * sum[d];\n        sum[d] += fp(a);\n        i64 dd = a / d;\n        if(dd != d) {\n          res += f[dd] * sum[dd];\n          sum[dd] += fp(a);\n        }\n      }\n    }\n    ans += res * fp(a);\n  }\n  cout \u003c\u003c ans \u003c\u003c endl;\n}\n```\n\n## 追記\n\n約数列挙にosa\\_k法を使うとめっちゃはやくなります。\n\n[提出コード](https://atcoder.jp/contests/agc038/submissions/31096206)\n\n## ABC248 G - GCD cost on the treeのパスグラフ版\n\n[ABC248 G - GCD cost on the tree](https://atcoder.jp/contests/abc248/tasks/abc248_g)のパスグラフ版から考えて、木に応用しようとしたけど失敗しちゃったのでパスグラフの解法だけでもメモっておきます...\n\n$N$要素からなる数列$A\\_0, \\cdots, A\\_{N - 1}$が与えられて以下を求める問題です。\n\n$$\n\\sum\\_{i = 0}^{N - 1} \\sum\\_{j = 0}^{i - 1} (i - j + 1) \\gcd(A\\_j, \\cdots, A\\_i)\n$$\n\n式変形していきます。\n\n$$\n\\begin{align}\n\u0026 = \\sum\\_{i = 0}^{N - 1} \\sum\\_{j = 0}^{i - 1} (i + 1) \\gcd(A\\_j, \\cdots, A\\_i) \\\\\\\\\n\u0026 - \\sum\\_{i = 0}^{N - 1} \\sum\\_{j = 0}^{i - 1} j \\gcd(A\\_j, \\cdots, A\\_i)\n\\end{align}\n$$\n\n\n$F(n) = n$として、その約数メビウス変換を$f(n)$とします。まずは前半部分を計算しましょう。\n$$\n\\begin{align}\n\u0026 \\sum\\_{i = 0}^{N - 1} \\sum\\_{j = 0}^{i - 1} (i + 1) \\gcd(A\\_j, \\cdots, A\\_i) \\\\\\\\\n= \u0026 \\sum\\_{i = 0}^{N - 1} (i + 1) \\sum\\_{j = 0}^{i - 1} F(\\gcd(A\\_j, \\cdots, A\\_i)) \\\\\\\\\n= \u0026 \\sum\\_{i = 0}^{N - 1} (i + 1) \\sum\\_{j = 0}^{i - 1} (\\sum\\_{d | A\\_j, \\cdots d | A\\_i} f(d)) \\\\\\\\\n\\end{align}\n$$\n\n先にあったような係数テクをします。\n\n$$\ns\\_j(d) = \n\\begin{cases}\n1 \u0026 d | A\\_j, \\cdots d | A\\_{i - 1} \\\\\\\\\n0 \u0026 \\text{otherwise}\n\\end{cases}\n$$\n\nとすると、\n\n$$\n\\begin{align}\n= \u0026 \\sum\\_{i = 0}^{N - 1} (i + 1) \\sum\\_{j = 0}^{i - 1} (\\sum\\_{d | A\\_i} f(d) s\\_j(d)) \\\\\\\\\n= \u0026 \\sum\\_{i = 0}^{N - 1} (i + 1) \\sum\\_{d | A\\_i} f(d) (\\sum\\_{j = 0}^{i - 1} s\\_j(d)) \\\\\\\\\n\\end{align}\n$$\n\n$\\sum\\_{j = 0}^{i - 1} s\\_j(d)$は、$i$を進めながら更新できます。$S\\_{i}(d) = \\sum\\_{j = 0}^{i - 1} s\\_j(d)$としたとき、\n\n$$\nS\\_{i + 1}(d) = \n\\begin{cases}\n1 + S\\_i(d) \u0026 d | A\\_i \\\\\\\\\n0 \u0026 \\text{otherwise}\n\\end{cases}\n$$\n\nとすればよいです。実装方法としては、$S\\_{i + 1}(d) \\neq 0$となる$d$の数が$O(\\sqrt A)$で抑えられることを活かす方法と、最後に$S(d)$を更新したときの$i$を記録しておく方法がありそうです。\n\n後半部分も計算します。\n\n$$\n\\begin{align}\n\u0026 \\sum\\_{i = 0}^{N - 1} \\sum\\_{j = 0}^{i - 1} j \\gcd(A\\_j, \\cdots, A\\_i) \\\\\\\\\n= \u0026 \\sum\\_{i = 0}^{N - 1} \\sum\\_{j = 0}^{i - 1} j F(\\gcd(A\\_j, \\cdots, A\\_i)) \\\\\\\\\n= \u0026 \\sum\\_{i = 0}^{N - 1} \\sum\\_{j = 0}^{i - 1} (\\sum\\_{d | A\\_j, \\cdots d | A\\_i} f(d) j) \\\\\\\\\n\\end{align}\n$$\n\n先にあったような係数テクをします。\n\n$$\nt\\_j(d) = \n\\begin{cases}\nj \u0026 d | A\\_j, \\cdots d | A\\_{i - 1} \\\\\\\\\n0 \u0026 \\text{otherwise}\n\\end{cases}\n$$\n\nとすると、\n\n$$\n\\begin{align}\n= \u0026 \\sum\\_{i = 0}^{N - 1} (i + 1) \\sum\\_{j = 0}^{i - 1} (\\sum\\_{d | A\\_i} f(d) t\\_j(d)) \\\\\\\\\n= \u0026 \\sum\\_{i = 0}^{N - 1} (i + 1) \\sum\\_{d | A\\_i} f(d) (\\sum\\_{j = 0}^{i - 1} t\\_j(d)) \\\\\\\\\n\\end{align}\n$$\n\n$T\\_{i} = \\sum\\_{j = 0}^{i - 1} t\\_j(d)$も同様に、$i$を進めながら更新できます。\n\n$$\nT\\_{i + 1}(d) = \n\\begin{cases}\ni + T\\_i(d) \u0026 d | A\\_i \\\\\\\\\n0 \u0026 \\text{otherwise}\n\\end{cases}\n$$\n\nこれでパスグラフに関しては解けているはず...？下に検証コードを載せておきます。\n\n```cpp\nconst i64 MAX = 1e5 + 1;\n\nfp solve(i64 N, vector\u003ci64\u003e A) {\n  vector\u003cfp\u003e f(MAX);\n  rep(i,0,MAX) f[i] = fp(i);\n  inverse_divisor_transform(f);\n\n  fp left;\n  {\n  vector\u003cpair\u003cint, fp\u003e\u003e sum(MAX, { -1, fp(0) });\n  rep(i,0,N) {\n    fp res;\n    for(i64 d = 1; d * d \u003c= A[i]; d++) {\n      if(A[i] % d == 0) {\n        auto\u0026 [b, s] = sum[d];\n        res += (b + 1 == i ? s : fp(0)) * f[d];\n        if(b + 1 != i) {\n          s = 0;\n        }\n        b = i;\n        s += fp(1);\n        if(A[i] / d != d) {\n          i64 dd = A[i] / d;\n          auto\u0026 [b, s] = sum[dd];\n          res += (b + 1 == i ? s : fp(0)) * f[dd];\n          if(b + 1 != i) {\n            s = 0;\n          }\n          b = i;\n          s += fp(1);\n        }\n      }\n    }\n    left += res * fp(i + 1);\n  }\n  }\n  {\n  vector\u003cpair\u003cint, fp\u003e\u003e sum(MAX, { -1, fp(0) });\n  rep(i,0,N) {\n    fp res;\n    for(i64 d = 1; d * d \u003c= A[i]; d++) {\n      if(A[i] % d == 0) {\n        auto\u0026 [b, s] = sum[d];\n        res += (b + 1 == i ? s : fp(0)) * f[d];\n        if(b + 1 != i) {\n          s = 0;\n        }\n        b = i;\n        s += fp(i);\n        if(A[i] / d != d) {\n          i64 dd = A[i] / d;\n          auto\u0026 [b, s] = sum[dd];\n          res += (b + 1 == i ? s : fp(0)) * f[dd];\n          if(b + 1 != i) {\n            s = 0;\n          }\n          b = i;\n          s += fp(i);\n        }\n      }\n    }\n    left -= res;\n  }\n  }\n  return left;\n}\n\ni64 gcd(i64 a, i64 b) {\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nfp naive(i64 N, std::vector\u003ci64\u003e A) {\n  fp ans;\n  rep(i,0,N) {\n    i64 G = A[i];\n    rep(j,i + 1,N) {\n      G = gcd(G, A[j]);\n      ans += fp(G) * fp(j - i + 1);\n    }\n  }\n  return ans;\n}\n\nint main() {\n  rep(s,0,1000) {\n    i64 N = 1000;\n    mt19937 mt(s);\n    uniform_int_distribution\u003c\u003e dist(1, (int)1e5);\n    vector\u003ci64\u003e A(N);\n    rep(i,0,N) A[i] = dist(mt);\n    cout \u003c\u003c \"seed: \" \u003c\u003c s \u003c\u003c endl;\n    //cout \u003c\u003c N \u003c\u003c endl;\n    //cout \u003c\u003c A \u003c\u003c endl;\n    fp so, na;\n    cout \u003c\u003c \"solve: \" \u003c\u003c (so = solve(N, A)) \u003c\u003c endl;\n    cout \u003c\u003c \"naive: \" \u003c\u003c (na = naive(N, A)) \u003c\u003c endl;\n    assert(so == na);\n  }\n}\n```\n\n木バージョンが解けないので、がんばる\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/divisor_transform_memo":{"title":"約数畳み込みを使って最大公約数と集合をうまく扱うメモ","content":"\n## とっても読みにくいので新しいのをよんで！！\n\n[あたらしいの]({{\u003c ref \"notes/divisor_transform2\" \u003e}})\n\n## ふるいの↓\n\n移植テストです\n\n書いて置かないと頭に置いておけない気がしたのでメモを残す. 間違ってたらごめん\n\nこれについて気になったので\n\n\u003cblockquote class=\"twitter-tweet\"\u003e\u003cp lang=\"ja\" dir=\"ltr\"\u003eメビウス関数とかを導入するとより形式的に約数とかを扱えるようになるのかなあ\u003c/p\u003e\u0026mdash; Niuez (@xiuez) \u003ca href=\"https://twitter.com/xiuez/status/1219811848263852033?ref_src=twsrc%5Etfw\"\u003eJanuary 22, 2020\u003c/a\u003e\u003c/blockquote\u003e \u003cscript async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"\u003e\u003c/script\u003e\n\n## 概要\n\n- 約数畳み込み\n- メビウス関数\n- メビウスの反転公式(約数畳み込みの逆操作)\n- 約数畳み込みと逆約数畳み込みのアルゴリズム $O(A \\log{\\log A})$\n- 最大公約数の扱い\n- 集合の扱い\n- [AGC038C LCMs](https://atcoder.jp/contests/agc038/tasks/agc038_c)の解き方\n\nネタバレあるので気をつけてください\n\n## 約数畳み込み\n\n関数$f(n)$に対する約数畳み込みとは, \n\n$\\begin{aligned} g(n) = \\sum\\_{ d | n } f(d) \\end{aligned}$\n\n\nあとで解説しますが, 方針としてはこの畳み込んだ後の$g(n)$を問題を解けるように定義してやることでGCDを綺麗に扱うことができます.\n\n## メビウス関数\n\n実際に$g(n)$を定義してみます. 一番有名なのは$g(n) = \\delta(n, 1)$です. $\\delta(n, 1)$はクロネッカーのデルタです. このとき, \n\n$\\begin{aligned} g(n) = \\delta(n, 1) = \\sum\\_{ d | n } f(d) \\end{aligned}$\n\nを満たす$f(n)$はメビウス関数と呼ばれ, $\\mu(n)$と書きます.([メビウス関数 - Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%93%E3%82%A6%E3%82%B9%E9%96%A2%E6%95%B0))\n\n## メビウスの反転公式(約数畳み込みの逆操作)\n\n上の式のままだと, $f(n)$を導くのは困難です. ここで登場するのがメビウスの反転公式です. これは, 約数畳み込みの逆操作に当たります.\n\n$$ \\begin{aligned}\ng(n) \u0026=\u0026 \\sum\\_{ d | n } f(d) \\\\\\\\\nf(n) \u0026=\u0026 \\sum\\_{ d | n } g(d) \\mu(\\frac{n}{d})\n\\end{aligned} $$\n\nこれで$g(n)$を定義してから反転公式を適用することで$f(n)$を導くことができます.\n\n## 約数畳み込みと逆約数畳み込みのアルゴリズム\n\n約数畳み込みとその逆はnoshi91さんが計算量$O(A \\log{\\log A})$で計算するアルゴリズムの記事を紹介しています. \n\n[http://noshi91.hatenablog.com/entry/2018/12/27/121649](http://noshi91.hatenablog.com/entry/2018/12/27/121649)\n\n\n逆約数畳み込みの実装例\n\n```cpp\ntemplate \u003cclass T\u003e\nvoid inverse_divisor_transform(vector\u003cT\u003e \u0026a) {\n    int n = a.size();\n    vector\u003cbool\u003e sieve(n, true);\n    for (int p = 2; p \u003c n; ++p) {\n        if (sieve[p]) {\n            for (int k = (n - 1) / p; k \u003e 0; --k) {\n                sieve[k * p] = false;\n                a[k * p] -= a[k];\n            }\n        }\n    }\n}\n```\n\n## 最大公約数の扱い\n\n自然数$n, m$に対して, \n\n$\\begin{aligned} \\sum\\_{d | n, d | m} f(d) \\end{aligned}$\n\nを考えると, \n\n$$\n\\begin{aligned}\n\\sum\\_{d | n, d | m} f(d) \u0026=\u0026 \\sum\\_{d | \\gcd(n, m)} f(d) \\\\\\\\\n\u0026=\u0026 g(\\gcd(n, m))\n\\end{aligned}\n$$\n\nとなり, $\\gcd(n, m)$に対する操作ができます. 例えば, $f(n) = \\mu(n), g(n) = \\delta(n, 1)$とすると, $g(\\gcd(n, m))$は,「$n, m$が互いに素であれば$1$, そうでなければ$0$」となり, 互いに素かどうかの判定ができます.\n\n## 集合の扱い\n\n例えば, $c\\_m(d) = [d | m$]という関数($d$が$m$を割り切るなら$1$, そうでなければ$0$)を考えると,\n\n$$ \\sum\\_{d | n, d | m} f(d) = \\sum\\_{ d | n } f(d) c\\_m(d) $$\n\nと変形できます.\n\nこれを応用します. 自然数の集合$S$ を考え, $c(d) = \\sum_{m \\in S} c\\_m(d)$とすると, \n\n$$\n\\begin{aligned}\n\\sum\\_{d | n} f(d) c(d) \u0026=\u0026 \\sum\\_{m \\in S}\\sum\\_{d | n} f(d) c\\_m(d) \\\\\\\\\n\u0026=\u0026 \\sum\\_{m \\in S} g(\\gcd(n, m))\n\\end{aligned}\n$$\n\nとなります.\n\n$f(n) = \\mu(n), g(n) = \\delta(n, 1)$を考えてみると, 「集合$S$の中に$n$と互いに素な要素の数」を計算しています.\n\n## AGC038C LCMsを解く\n\n\n\u003cblockquote\u003e\u003ch4\u003e\u003ca href=\"https://atcoder.jp/contests/agc038/tasks/agc038_c\"\u003eAGC038 C - LCMs\u003c/a\u003e\u003c/h4\u003e\u003c/blockquote\u003e\n\n$lcm(x, y) = x (\\frac{y}{\\gcd(x, y)})$と変形します. 約数畳み込みを使う方針でやると, この$(\\frac{y}{\\gcd(x, y)})$が最後に来てほしい気持ちになります. $g(n) = \\frac{1}{n}$と置くと, \n\n$$\n\\begin{aligned}\n\\frac{y}{\\gcd(x, y)} \u0026=\u0026 y \\cdot g(\\gcd(x, y)) \\\\\\\\\n\u0026=\u0026 \\sum\\_{d | gcd(x, y)} f(d) y \\\\\\\\\n\u0026=\u0026 \\sum\\_{d | x, d | y} f(d) y \\\\\\\\\n\u0026=\u0026 \\sum\\_{d | x} f(d) s\\_y(d)\n\\end{aligned}\n$$\n\nここで$s\\_y(d)$を「$d$が$y$を割り切るなら$y$, そうでなければ$0$」としました.  \n応用して, 自然数の集合$S$ を考え, $s(d) = \\sum_{m \\in S} s\\_m(d)$とすると, \n\n$$\n\\begin{aligned}\n\\sum\\_{d | x} f(d) s(d) \u0026=\u0026 \\sum\\_{y \\in S}\\sum\\_{d | x} f(d) s\\_y(d) \\\\\\\\\n\u0026=\u0026 \\sum\\_{y \\in S} y \\cdot g(\\gcd(x, y))\n\\end{aligned}\n$$\n\nと計算できて, これに$x$を掛けると「集合$S$の中の各要素と$x$の最大公約数の和」を計算できました.  \n計算量は, $O(A \\log{\\log A} + N \\sqrt A)$です.\n\n\n\u003ca href=\"https://atcoder.jp/contests/agc038/submissions/9703431\"\u003eC - LCMs の僕の提出\u003c/a\u003e\n\nソースコード\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) \u003c (e);(i)++)\n\n/* modint */\n/* IO(niu::fin, niu::fout) */\n\nconst i64 MOD = 998244353;\nusing fp = modint\u003cMOD\u003e;\n\n\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n\ntemplate \u003cclass T\u003e\nvoid inverse_divisor_transform(vector\u003cT\u003e \u0026a) {\n    int n = a.size();\n    vector\u003cbool\u003e sieve(n, true);\n    for (int p = 2; p \u003c n; ++p) {\n        if (sieve[p]) {\n            for (int k = (n - 1) / p; k \u003e 0; --k) {\n                sieve[k * p] = false;\n                a[k * p] -= a[k];\n            }\n        }\n    }\n}\n\nconstexpr i64 A = 1e6 + 1;\n\nint main() {\n  std::vector\u003cfp\u003e f(A);\n  rep(d,1,A) {\n    f[d] = fp(d).pow(MOD - 2);\n  }\n  inverse_divisor_transform(f);\n\n  i64 N;\n  niu::fin \u003e\u003e N;\n  vector\u003cfp\u003e sum(A);\n  fp ans = 0;\n  rep(i,0,N) {\n    int x;\n    niu::fin \u003e\u003e x;\n    fp res = 0;\n    for(int d = 1; d * d \u003c= x; d++) {\n      if(x % d == 0) {\n        res += f[d] * sum[d];\n        sum[d] += fp(x);\n        if(x / d != d) {\n          res += f[x / d] * sum[x / d];\n          sum[x / d] += fp(x);\n        }\n      }\n    }\n    ans += res * fp(x);\n  }\n  niu::fout \u003c\u003c ans.value() \u003c\u003c \"\\n\";\n}\n```\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/edpc-m":{"title":"EDPC M - CandiesをFPSで","content":"\n[EDPC M - Candies](https://atcoder.jp/contests/dp/tasks/dp_m)\n\n$$\n\\begin{align}\n\u0026 \\prod\\_{i = 1}^{N} (1 + x + \\cdots + x^{a\\_i}) \\\\\\\\\n\u0026 = \\prod\\_{i = 1}^{N} \\frac{1 - x^{a\\_i + 1}}{1 - x} \\\\\\\\\n\u0026 = (1 - x)^{-N} \\prod\\_{i = 1}^{N} (1 - x^{a\\_i + 1})\n\\end{align}\n$$\n\n$\\prod\\_{i = 1}^{N} (1 - x^{a\\_i + 1})$はdpで計算して$O(N K)$、$(1 - x)^{-N}$はN回累積和の操作に対応するので$O(N K)$です。\n\n[提出コード](https://atcoder.jp/contests/dp/submissions/30922282)\n\n```cpp\ni64 N, K;\ncin \u003e\u003e N \u003e\u003e K;\nvector\u003ci64\u003e A(N);\nrep(i,0,N) {\n  cin \u003e\u003e A[i];\n  A[i]++;\n}\nvector\u003cfp\u003e dp(K + 1);\ndp[0] = 1;\nrep(i,0,N) {\n  for(i64 j = K + 1; j --\u003e A[i];) {\n    dp[j] -= dp[j - A[i]];\n  }\n}\nrep(i,0,N) {\n  rep(j,1,K + 1) {\n    dp[j] += dp[j - 1];\n  }\n}\ncout \u003c\u003c dp[K] \u003c\u003c endl;\n```\n\n負の二項定理を使えば、最後のパートを$(N + K)$で計算できそう。\n\n[提出コード](https://atcoder.jp/contests/dp/submissions/30942002)\n\n```cpp\ni64 N, K;\ncin \u003e\u003e N \u003e\u003e K;\nvector\u003ci64\u003e A(N);\nrep(i,0,N) {\n  cin \u003e\u003e A[i];\n  A[i]++;\n}\nvector\u003cfp\u003e dp(K + 1);\ndp[0] = 1;\nrep(i,0,N) {\n  for(i64 j = K + 1; j --\u003e A[i];) {\n    dp[j] -= dp[j - A[i]];\n  }\n}\nfact.build(N + K);\nfp ans;\nrep(i,0,K + 1) {\n  ans += dp[i] * fact.binom(K - i + N - 1, N - 1);\n}\ncout \u003c\u003c ans \u003c\u003c endl;\n```\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/entry/2019/03/04/142903":{"title":"ダイクストラとポテンシャルのはなし","content":"はじめまして, niuezといいます. 競プロを少ししています.\n\n最近勉強したことのメモ書きをしておきます.\n\n## ダイクストラ法\n\nダイクストラ法(\u003cem\u003eDijkstra\u003c/em\u003e)は負の長さの無いグラフで始点からの最短距離を求めるアルゴリズムです.\n\n具体的には\n\n\u003col\u003e\n\u003cli\u003e距離が未確定の頂点の中で一番小さいものを選び, 距離を確定させる.\u003c/li\u003e\n\u003cli\u003e選んだ頂点から距離が未確定の頂点に伸びる辺で, 未確定な距離をより短いものに更新する.\u003c/li\u003e\n\u003c/ol\u003e\n\n\nを繰り返します. これを実装すると $O(N)$ですが, よく知られるダイクストラの計算量は $O((E+ V) \\log E)$ です(heapとかを使う).\n\n```cpp\n#include \u003cset\u003e\u003c/set\u003e\n#include \u003cqueue\u003e\u003c/queue\u003e\n#include \u003cvector\u003e\u003c/vector\u003e\n\nstruct edge {\n  int u,v;\n  int dist;\n};\n\nstd::vector\u0026lt;int\u003e dijkstra(const std::vector\u0026lt;std::vector\u0026lt;edge\u003e\u003e\u0026amp; g, int s) {\n  std::vector\u0026lt;int\u003e dist(g.size(), 1e9);\n  using node = std::pair\u0026lt;int,int\u003e;\n  std::priority_queue\u0026lt;node,std::vector\u0026lt;node\u003e, std::greater\u0026lt;node\u003e\u003e Q;\n  dist[s] = 0;\n  Q.push(node(dist[s], s));\n\n  while(!Q.empty()) {\n    int v = Q.top().second;\n    int d = Q.top().first;\n    Q.pop();\n    if(dist[v] \u0026lt; d) continue;\n    for(const auto\u0026amp; e: g[v]) {\n      if(dist[e.u] + e.dist \u0026lt; dist[e.v]) {\n        dist[e.v] = dist[e.u] + e.dist;\n        Q.push(node(dist[e.v], e.v));\n      }\n    }\n  }\n\n  return std::move(dist);\n}\n\n```\n\n\n## ベルマンフォード法\n\nベルマンフォード法(\u003cem\u003eBellman-Ford\u003c/em\u003e)は任意の長さのグラフで始点からの最短距離を求めるアルゴリズムです. 負の長さの閉路があるときはもちろん求められませんが, この記事では考えないことにします.\n\n$O(VE)$ で直感的にもわかりやすいアルゴリズムですね.\n\n```cpp\n#include \u003cvector\u003e\u003c/vector\u003e\n\nstruct edge {\n  int u,v;\n  int dist;\n};\n\nstd::vector\u0026lt;int\u003e dijkstra(const std::vector\u0026lt;std::vector\u0026lt;edge\u003e\u003e\u0026amp; g, int s) {\n  std::vector\u0026lt;int\u003e dist(g.size(), 1e9);\n  dist[s] = 0;\n\n  for(int c = 0;c \u0026lt; g.size();c++) {\n      for(int v = 0;v \u0026lt; g.size();g++) {\n          if(dist[v] == (int)1e9) continue;\n          for(const auto\u0026amp; e: g[v]) {\n            if(dist[e.u] + e.dist \u0026lt; dist[e.v]) {\n                dist[e.v] = dist[e.u] + e.dist;\n            }\n          }\n      }\n  }\n\n  return std::move(dist);\n}\n\n```\n\n\n## 負の重みがあるときはベルマンフォード法しか無い?\n\nダイクストラ法のほうが定数倍が早かったりするので, できるだけベルマンフォード法よりはダイクストラ法を使いたいですよね?\n\n\u003cstrong\u003e一回だけ\u003c/strong\u003e最短経路を求めるときはベルマンフォード法を使うしかありません.\n\n\u003cstrong\u003e複数回\u003c/strong\u003e最短経路を求めるときはどうでしょうか?\n\n実はこの場合, ベルマンフォード法を最初に一回だけしておくことで, 後の複数回はダイクストラ法を使うことが出来ます.\n\nダイクストラ法を使うとすると, 辺の長さを\u003cstrong\u003eうまいことして正の長さにする\u003c/strong\u003e必要があります.\n\n## 最短経路とは??\n\n始点を頂点 $s$ とした最短経路を数式に落とし込むと, こういう定義になります.\n\n$d_s = 0$ とする.\u003cbr/\u003e\nすべての辺 $(i,j)$ において $d_i + dist(i,j) \\ge d_j$ が成り立つときの, $d$ のそれぞれの取れる最大値.\n\nこれを頭に入れておくと次がわかります.\n\n## ポテンシャル\n\nここで天才をします. 先人は天才です.\n\nある$p_i$という値を用意して, 距離を $dist\u0026#39;(i,j) = dist(i,j) + p_i - p_j$ としたグラフを考えます.\n\n長さ $dist\u0026#39;$ のグラフで, 頂点 $s$ を始点とした最短距離を計算して, ${d\u0026#39;}_i$ を求めたとしましょう.\n\n\u003cdiv\u003e${d\u0026#39;}_i + dist\u0026#39;(i, j) \\ge {d\u0026#39;}_j$\u003c/div\u003e\n\n\n\n\n\u003cdiv\u003e${d\u0026#39;}_i + dist(i, j) + p_i - p_j \\ge {d\u0026#39;}_j$\u003c/div\u003e\n\n\n\n\n\u003cdiv\u003e${d\u0026#39;}_i + p_i + dist(i, j) \\ge {d\u0026#39;}_j + p_j$\u003c/div\u003e\n\n\nよく見ると\n\n\u003cdiv\u003e $d_i = {d\u0026#39;}_i + p_i$ \u003c/div\u003e\n\n\nとすれば, $d_i$は最短距離の定義を満たしているように見えますね.しかし\n\n\u003cdiv\u003e$d_s = {d\u0026#39;}_s + p_s = p_s`$ \u003c/div\u003e\n\n\nなので\u003cbr/\u003e\n$d_s = 0$ を満たしていません. \u003cbr/\u003e\nなので, すべての頂点 $i$ について $ans_i = {d\u0026#39;}_i + p_i - p_s$ を計算すれば, $ans$ は最短経路を示しています.\n\nこのとき, $p_i$ のことを\u003cstrong\u003eポテンシャル\u003c/strong\u003eと呼びます.\n\nでは, \u003cstrong\u003e$dist\u0026#39;$を正の長さにしたい\u003c/strong\u003e気持ちになります.\n\n\u003cdiv\u003e$dist(i, j) + p_i - p_j \\ge 0$\u003c/div\u003e\n\n\n\u003cdiv\u003e$p_i + dist(i, j) \\ge p_j$\u003c/div\u003e\n\n\nこれは何かな. 最短距離の定義そのままですね(天才).\n\nこれを使うと色々なものが効率的に求めることが出来ます.\n\n## 負の重みがあるグラフでの全点間最短距離問題\n\n全点間最短距離問題とは, すべての頂点の間での最短距離を計算する問題のことです.\n\nよく知られているのはワーシャルフロイド法の \u003cspan\u003e$O(V\u003csup\u003e3\u003c/sup\u003e)$\u003c/span\u003e ですが, これを \u003cspan\u003e$V$\u003c/span\u003e 回のダイクストラに置き換えることが出来て, $O(V(E + V) \\log V)$ になります.\n\n疑似コード\n\n```\nproc all_pair_shortest_path(G, dist)\n    let potential = bellman_ford(G, dist, 0) //引数は グラフ, 距離, 始点 です\n    for e = (i, j) in G\n        dist2(i, j) = dist(i, j) + potential[i] - potential[j]\n    for s in [0, |V| - 1]\n        result[s] = dijkstra(G, dist2, s)\n        for j in [0, |V| - 1]\n            result[s][j] += potential[j] - potential[s] // result[s][j]... s -\u003e jの距離\n    return result\n```\n\n\n## 最小費用流\n\n最小費用流はたぶん皆さんなら, 最短路反復法で実装していると思いますが...(\u003cem\u003eRHS-algorithm\u003c/em\u003eなんて強多項式計算量知らない)\n\nこのとき負の辺があるときはダイクストラが使えないと思われがちですが, 同じように最初にベルマンフォードでポテンシャルを求めておけば, 高速で計算が可能です.\n\nしかし, 逆辺が負の重みを持つので, ポテンシャルは, その時求めた最短距離を加算して行くことで, 更新をし続けなければなりません.\n\n\u003ca href=\"https://tubo28.me/algorithm/primal-dual/\"\u003elibalgo\u003c/a\u003eが参考になります.\n\n## スケーリングアルゴリズム\n\nスケーリングを用いたダイクストラのアルゴリズムは重みが非負整数のときに使える高速化手法です.\n\n簡潔に言うと, 「辺の重みを半分にしたものでダイクストラをして, その結果の二倍をポテンシャルに使ってダイクストラをする.」 を再帰的に行うことで, ダイクストラを高速化するテクを使うというアルゴリズムです.\n\n下に例を示します.\n\n{{\u003c figure src=\"/images/2019/03/04/142903/20190304120801.png\"  \u003e}}\n\nこのようなグラフがあったとします.\n\nこのグラフの重みを半分にした(小数点以下切り捨て) グラフでダイクストラをします.\n\n{{\u003c figure src=\"/images/2019/03/04/142903/20190304120815.png\"  \u003e}}\n\n最短距離は赤色に示した通りです.\n\nこの値を二倍した値を, 半分にする前のグラフのポテンシャルに使います.\n\n{{\u003c figure src=\"/images/2019/03/04/142903/20190304120824.png\"  \u003e}}\n\n辺の重みをポテンシャルによって置き換えると以下のようになります.\n\n{{\u003c figure src=\"/images/2019/03/04/142903/20190304120834.png\"  \u003e}}\n\nこの置き換えた重みでダイクストラをします.\n\n{{\u003c figure src=\"/images/2019/03/04/142903/20190304121550.png\"  \u003e}}\n\n最短距離は青色で示しました.\n\nそれぞれの頂点で赤色と青色の値を足すと, ポテンシャルの性質により半分にする前のグラフの最短距離が求まります.\n\n{{\u003c figure src=\"/images/2019/03/04/142903/20190304120846.png\"  \u003e}}\n\nこのグラフの重みは二進数にしたとき高々2桁なので1回半分にするだけで済みましたが, 一般に $ \\log W$ 回再帰的に「重みを半分にして二倍してポテンシャルに使う」という動作をすれば求まります.\n\n## 高速化\n\n正直こんなことしなくてもこのままのアルゴリズムであれば, 大元のグラフをダイクストラすればいいだけの話です.\n\nですが, このポテンシャルで変更を加えた後のグラフに性質があります.\n\n重みを半分にしたグラフでの, 頂点$s$から頂点$g$の最短経路($P$とします)に含まれる辺の数を $L$とします.\n\nこのとき, 半分にする前の重みをポテンシャルで変更を加えたグラフでの $s$から$g$の最短経路の重みは $L$以下です.\n\nなぜなら, 二進数を考えると$P$上の辺の重みはポテンシャルで変更を加えると $0$ か $1$にしかならないからです.\n\nつまりこのスケーリングアルゴリズムで行うダイクストラは, $V$個のQueueを用意してダイクストラをするものを使えば $O(m + n \\log W)$ で計算できます.\n\n## 〆\n\n実はダイクストラの定数倍が速すぎてスケーリングはそんなに速くなりません\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/entry/2019/06/29/161729":{"title":"top-tree実装体験木","content":"読者層が限定されすぎていませんか？\n\nLink Cut Treeを書いたことがない人はこちら！\n\n[Link-Cut 木 - ei1333の日記](https://ei1333.hateblo.jp/entry/2018/05/29/011140)\n\n部分木クエリについてはこちら！\n\n[Link Cut Treeで部分木の情報を管理する - beet\u0026#39;s soil](http://beet-aizu.hatenablog.com/entry/2019/06/08/221833)\n\n最遠点クエリについてはこちら！\n\n[Link-Cut木と最遠点クエリ - ei1333の日記](https://ei1333.hateblo.jp/entry/2019/06/13/133736)\n\nえ〜っと, 多分toptreeが書けました. 多分!  verifyしたいんですが, Rustのバージョンで困っています...\n\n## 実装\n\n論文を読むとかける！(素振り) 間違ってたらごめんなさい\n\n\n\u003cdiv class=\"github-card\" data-user=\"kutimoti\" data-repo=\"toptree-rust\" data-width=\"400\" data-height=\"\" data-theme=\"default\"\u003e\u003c/div\u003e\n\u003cscript src=\"https://cdn.jsdelivr.net/github-cards/latest/widget.js\"\u003e\u003c/script\u003e\n\n\nLinkCutTreeがならしO(logN)らしいし, これもO(logN)だと信じている(解析できねえ...)\n\n## 読んだもの\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://arxiv.org/abs/cs/0310065\"\u003eMaintaining Information in Fully-Dynamic Trees with Top Trees\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://renatowerneck.files.wordpress.com/2016/06/wer06-dissertation.pdf\"\u003eDesign and Analysis of Data Structures for Dynamic Trees\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003enoshi91さんのツイート\u003c/li\u003e\n\u003c/ul\u003e\n\n\n## toptree?\n\nLinkCutTreeでは, Heavy-edgeのパスを頂点の順番でSplayTreeで管理していました. また, 上のLinkCutTreeでの部分木クエリでは, Light-edgeでつながったものを, multisetで管理しています.\n\nこれを, Heavy-edgeのパスを辺の順番で, \u003cstrong\u003e辺を葉とする\u003c/strong\u003eSplayTreeで管理し, \u003cstrong\u003eLight-edgeでつながったものをSplayTreeでまとめた\u003c/strong\u003eデータ構造が, TopTreeの雑な説明です. このSplayTreeにクエリを処理させれば, 部分木クエリなどができます. link, cutもできます.\n\nここでもっと雑な説明をしてしまうとTopTreeが分からなくなってしまいそうなので, 他の記事にゆっくりまとめたいと思います... まとめる時間をください...(学業がなくなれば)\n\n## 実際にできたクエリ\n\nTopTreeにはClusterを載せてクエリを処理させます. ClusterのTraitは以下のようになっています.\n\n```rust\npub trait Cluster: Clone {\n    fn identity() -\u003e Self;\n    fn compress(left: Self, right: Self) -\u003e Self;\n    fn rake(left: Self, right: Self) -\u003e Self;\n    fn reverse(\u0026amp;mut self);\n}\n\n```\n\n\n### v-uパスの長さ\n\n```rust\nimpl Cluster for usize {\n    fn identity() -\u003e Self { 0 }\n    fn compress(left: Self, right: Self) -\u003e Self { left + right }\n    fn rake(a: Self, _: Self) -\u003e Self { a }\n    fn reverse(\u0026amp;mut self) {}\n}\n\n```\n\n\nというふうにClusterを定義すると\n\n```rust\npub fn path_length_test() {\n    println!(\"path_length\");\n    let v: Vec\u0026lt;_\u003e = (0..13).map(|i| Vertex::new(i)).collect();\n    let edges = [\n        (0usize, 1usize, 1usize),\n        (1, 2, 10),\n        (1, 3, 3),\n        (1, 4, 4),\n        (0, 5, 3),\n        (5, 9, 4),\n        (9, 10, 7),\n        (10, 11, 9),\n        (10, 12, 1),\n        (0, 6, 3),\n        (6, 7, 3),\n        (7, 8, 7),\n    ];\n    let mut es = Vec::new();\n    for (a, b, w) in edges.iter() {\n        es.push(link(v[*a], v[*b], *w));\n    }\n    assert!(path_query(v[1], v[0]) == 1);\n    assert!(path_query(v[0], v[4]) == 5);\n    assert!(path_query(v[1], v[9]) == 8);\n    assert!(path_query(v[3], v[11]) == 27);\n    assert!(path_query(v[6], v[12]) == 18);\n    assert!(path_query(v[12], v[6]) == 18);\n    assert!(path_query(v[2], v[4]) == 14);\n    assert!(path_query(v[5], v[6]) == 6);\n}\n\n```\n\n\n### 木の直径クエリ\n\n```rust\n#[derive(Clone, Debug)]\nstruct Diameter {\n    diam: usize,\n    max_dist_left: usize,\n    max_dist_right: usize,\n    length: usize\n}\n\nimpl Diameter {\n    fn new(l: usize) -\u003e Self {\n        Diameter {\n            diam: l,\n            max_dist_left: l,\n            max_dist_right: l,\n            length: l,\n        }\n    }\n}\n\nimpl Cluster for Diameter {\n    fn identity() -\u003e Self {\n        Diameter {\n            diam: 0,\n            max_dist_left: 0,\n            max_dist_right: 0,\n            length: 0,\n        }\n    }\n    fn compress(a: Self, b: Self) -\u003e Self {\n        Diameter {\n            diam: *[ a.diam, b.diam, a.max_dist_right + b.max_dist_left].into_iter().max().unwrap(),\n            max_dist_left: std::cmp::max(a.max_dist_left, a.length + b.max_dist_left),\n            max_dist_right: std::cmp::max(b.max_dist_right, b.length + a.max_dist_right),\n            length: a.length + b.length\n        }\n    }\n    fn rake(a: Self, b: Self) -\u003e Self {\n        Diameter {\n            diam: *[ a.diam, b.diam, a.max_dist_right + b.max_dist_right ].into_iter().max().unwrap(),\n            max_dist_left: std::cmp::max(a.max_dist_left, a.length + b.max_dist_right),\n            max_dist_right: std::cmp::max(a.max_dist_right, b.max_dist_right),\n            length: a.length,\n        }\n    }\n    fn reverse(\u0026amp;mut self) {\n        std::mem::swap(\u0026amp;mut self.max_dist_left, \u0026amp;mut self.max_dist_right);\n    }\n}\n\n```\n\n\nというふうにClusterを定義すると\n\n```rust\npub fn diameter_cut_test() {\n    println!(\"diameter cut\");\n    let v: Vec\u0026lt;_\u003e = (0..13).map(|i| Vertex::new(i)).collect();\n    let edges = [\n        (0usize, 1usize, 1usize),\n        (1, 2, 10),\n        (1, 3, 3),\n        (1, 4, 4),\n        (0, 5, 3),\n        (5, 9, 4),\n        (9, 10, 7),\n        (10, 11, 9),\n        (10, 12, 1),\n        (0, 6, 3),\n        (6, 7, 3),\n        (7, 8, 7),\n    ];\n    let mut es = Vec::new();\n    for (a, b, w) in edges.iter() {\n        es.push(link(v[*a], v[*b], Diameter::new(*w)));\n    }\n    cut(v[0], v[5]);\n    println!(\"0 diameter = {}\", expose(v[0]).fold().diam); // -\u003e 24\n    println!(\"5 diameter = {}\", expose(v[5]).fold().diam); // -\u003e 20\n}\n\n```\n\n\nAOJの直径のやつ適当にいくつか通しました(提出できない)\n\n### 最遠点クエリ\n\n```rust\n#[derive(Clone, Debug)]\nstruct Farthest {\n    ans: usize,\n    max_dist_left: usize,\n    max_dist_right: usize,\n    length: usize\n}\n\nimpl Farthest {\n    fn new(l: usize) -\u003e Self {\n        Farthest {\n            ans: l,\n            max_dist_left: l,\n            max_dist_right: l,\n            length: l,\n        }\n    }\n}\n\nimpl Cluster for Farthest {\n    fn identity() -\u003e Self {\n        Farthest {\n            ans: 0,\n            max_dist_left: 0,\n            max_dist_right: 0,\n            length: 0,\n        }\n    }\n    fn compress(a: Self, b: Self) -\u003e Self {\n        Farthest {\n            ans: std::cmp::max(a.max_dist_right, b.max_dist_left),\n            max_dist_left: std::cmp::max(a.max_dist_left, a.length + b.max_dist_left),\n            max_dist_right: std::cmp::max(b.max_dist_right, b.length + a.max_dist_right),\n            length: a.length + b.length\n        }\n    }\n    fn rake(a: Self, b: Self) -\u003e Self {\n        Farthest {\n            ans: 0,\n            max_dist_left: std::cmp::max(a.max_dist_left, a.length + b.max_dist_right),\n            max_dist_right: std::cmp::max(a.max_dist_right, b.max_dist_right),\n            length: a.length,\n        }\n    }\n    fn reverse(\u0026amp;mut self) {\n        std::mem::swap(\u0026amp;mut self.max_dist_left, \u0026amp;mut self.max_dist_right);\n    }\n}\n\n```\n\n\nというふうにClusterを定義すると\n\n[J - 仕事をしよう！ (Working!)](https://atcoder.jp/contests/tkppc/tasks/tkppc2015_j)\n\nが解けます. サンプルは通りました(AtCoderさんverifyさせてくださいおねがいします)\n\n```rust\npub fn farthest_test() {\n    println!(\"farthest\");\n    let mut buf = String::new();\n    std::io::stdin().read_to_string(\u0026amp;mut buf).unwrap();\n    let mut iter = buf.split_whitespace();\n    let q: usize = iter.next().unwrap().parse().unwrap();\n\n    let mut v: Vec\u0026lt;_\u003e = (0..1).map(|_| Vertex::new(())).collect();\n    let edges :Vec\u0026lt;(usize, usize, usize)\u003e= (0..q).map(|_| {\n        (\n            iter.next().unwrap().parse().unwrap(),\n            iter.next().unwrap().parse().unwrap(),\n            iter.next().unwrap().parse().unwrap(),\n            )\n    }).collect();\n    let mut es = Vec::new();\n    for (t, a, c) in edges.iter() {\n        if *t == 1 {\n            let new_v = Vertex::new(());\n            v.push(new_v);\n            link(v[*a], new_v, Farthest::new(*c));\n            es.push((*a, v.len() - 1));\n        }\n        else if *t == 2 {\n            let p = es[*a - 1].0;\n            let q = es[*a - 1].1;\n            cut(v[p], v[q]);\n            link(v[p], v[q], Farthest::new(*c));\n        }\n        else if *t == 3 {\n            println!(\"farthest from {} = {}\", *a, expose(v[*a]).fold().ans);\n        }\n    }\n}\n\n```\n\n\nNearest Marked Vertex Queryはまだやってない.\n\n何が載るのかはさっぱりわかりません, だれか解明して.\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/entry/2019/08/04/191420":{"title":"Toptree 導入編","content":"みんな日本語記事を待っていたはず....!\n\ntoptreeがどんな感じで動いているのかを書いてみます\n\n実装はここにあります\n\n\u003ca href=\"https://github.com/niuez/toptree-rust\"\u003ehttps://github.com/niuez/toptree-rust\u003c/a\u003e\n\n## 0. toptree is なに\n\ntoptreeはlink-cut treeの上位互換です. 木を切ったりつなげたり, パスのクエリを処理したり, 木上の二分探索ができたりします\n\n今回はそのベースとなる構造の話です\n\n## 1. Compress Rake\n\n### 木をまとめる\n\nここで言う木は, toptreeが表す木のことです. 曖昧にならないようにこのことを\u003ccode\u003ereal tree\u003c/code\u003eと呼ぶことにします. (木を木で表現するの文章が曖昧になりがち)\n\ntoptreeでは, つながっている2つの辺をまとめる操作を繰り返したものを表現した木です.\n1つの辺にまとめ上げることでパスを表現します.\n\nまとめる操作は２つあり, それぞれ\u003cstrong\u003eCompress\u003c/strong\u003e, \u003cstrong\u003eRake\u003c/strong\u003eといいます.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184030.png\"  \u003e}}\n\n### 具体的に\n\nこんな感じでまとめていきます\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184116.png\"  \u003e}}\n\nこのまとめていく操作を木で表現するのがtoptreeです.\n\n### Compress Tree\n\n例えば, \u003ccode\u003ea - c - b\u003c/code\u003eという一直線の\u003ccode\u003ereal tree\u003c/code\u003eを扱う時, 辺\u003ccode\u003eac\u003c/code\u003eと\u003ccode\u003ecb\u003c/code\u003eをcompressをします.\u003cbr/\u003e\nこれをtoptreeで表現すると\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184140.png\"  \u003e}}\n\n四角は辺を表すノードです. Edge Nodeといいます. toptreeでは, Edge Nodeを葉にします.\n丸はcompressした後の辺を表すノードです. Compress Nodeといいます.\u003cbr/\u003e\nCompress Nodeが節, Edge Nodeが葉のこの木をCompress Treeといいます.\u003cbr/\u003e\n重要なのは, \u003cstrong\u003eCompress Treeの根がパスの端点を結ぶ, Compressされた辺を表している\u003c/strong\u003eということです. またそのcompressされた辺の端点は\u003cstrong\u003e必ず次数が1\u003c/strong\u003eです.\n\n\u003ccode\u003e0 - 1 - 2 - 3 - 4 - 5\u003c/code\u003e という\u003ccode\u003ereal tree\u003c/code\u003eをtoptreeで表すと, 一例としては以下のようになります.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184203.png\"  \u003e}}\n\n### 辺の向き付け\n\nここで葉のEdge Nodeの順番がパスの辺の順番になっている点に注意してください.\n\ntoptreeでは辺の向きに注意して操作しないとダメです.\u003cbr/\u003e\n僕の実装では, \u003ccode\u003e0 - 1 - 2 - 3 - 4 - 5\u003c/code\u003eのtoptreeを\u003ccode\u003e0 -\u003e 1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e 5\u003c/code\u003eと向き付けると解釈しています. 以後の\u003ccode\u003ereal tree\u003c/code\u003eの図では向き付けしたものを用います.\n\ncompress, rakeを, \u003cstrong\u003e同じ向きのものをまとめる操作\u003c/strong\u003eと解釈することにしましょう. すると, compress, rakeを向き付けた\u003ccode\u003ereal tree\u003c/code\u003eについて改めて考えると以下のようになります.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184231.png\"  \u003e}}\n\n上の\u003ccode\u003e具体的に\u003c/code\u003eで示した\u003ccode\u003ereal tree\u003c/code\u003eはこんな感じで向き付けすると同じようにまとめる操作ができるはずです.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184250.png\"  \u003e}}\n\n### Rake Tree\n\nでは一直線ではない\u003ccode\u003ereal tree\u003c/code\u003e, 例えばこれはどうやってtoptreeにするのでしょうか.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184307.png\"  \u003e}}\n\nここでrakeを使います.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184324.png\"  \u003e}}\n\n?????????????????????\n\n辺\u003ccode\u003e14\u003c/code\u003eを追加した\u003ccode\u003ereal tree\u003c/code\u003eをtoptreeにすると\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184342.png\"  \u003e}}\n\nひし形のノードはcompressと同じように察せるはずです. \u003ccode\u003e31\u003c/code\u003eと\u003ccode\u003e41\u003c/code\u003eをrakeしたものを表現しており, ひし形のノードをRake Nodeといいます.\u003cbr/\u003e\nまた, Rake Nodeが節, Compress Treeの根が葉の木をRake Treeといいます.\n\n図では, Compress Nodeに今までの左右の子と, 赤の線でつながった子があります.\u003cbr/\u003e\n赤の線でつながった子は, Compress Nodeの右の子とrakeされるノードです.\n\nこのように3分木にして\u003ccode\u003ereal tree\u003c/code\u003eの情報を持ちます.\n\n### 具体例のtoptree\n\nこんな感じになります\u003cbr/\u003e\n四角はEdge Node, 丸はCompress Node, ひし形はRakeNodeです.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184401.png\"  \u003e}}\n\nCompress Tree(青の点線で囲った部分), Rake Tree(赤の点線で囲った部分)はそれぞれここです\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184413.png\"  \u003e}}\n\n## Splice\n\n\u003e重要なのは, Compress Treeの根がパスの端点を結ぶ, Compressされた辺を表しているということです.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184307.png\"  \u003e}}\n\nこの木のtoptreeをもう一度見てみます.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184324.png\"  \u003e}}\n\n\u003ccode\u003e0 - 1 - 2\u003c/code\u003eがこのtoptreeの主役のパスになっています.\n\nでも, \u003ccode\u003e3 - 1 - 2\u003c/code\u003eを主役にしたいときもあるはずです. それは, \u003ccode\u003e31\u003c/code\u003eと\u003ccode\u003e01\u003c/code\u003eを入れ替えることで達成できます.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184546.png\"  \u003e}}\n\n\u003ccode\u003e0 - 1 - 3\u003c/code\u003eにを主役にしたいときもあるはずです. それは, \u003ccode\u003e31\u003c/code\u003eと\u003ccode\u003e12\u003c/code\u003eの向きを反転させてから入れ替えることで達成できます.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184558.png\"  \u003e}}\n\nこの, Rake Treeの葉のノードと, Compress nodeの子を入れ替えてCompress Nodeの表すパスを変える操作を\u003ccode\u003esplice\u003c/code\u003eといいます.\n\n## Splay\n\nSplay Treeを知っていますか? wikipediaを見て\n\nSplay Treeでは, \u003ccode\u003esplay\u003c/code\u003eという木を回転させてノードを根に持ってくるという操作をします. まあwikipediaみて\u003cbr/\u003e\ntoptreeで扱っている木は, 葉木です. 葉は\u003ccode\u003esplay\u003c/code\u003eできないことに注意しましょう.\n\n## Handle\n\n\u003ccode\u003esplice\u003c/code\u003eをするとパスを変形できることはわかりましたが, 具体的にどのノードを\u003ccode\u003esplice\u003c/code\u003eすると良いのでしょうか?\n\nそれを示すのが\u003ccode\u003ehandle\u003c/code\u003eという概念です. \u003ccode\u003ehandle\u003c/code\u003eは各頂点に対して割り振られるもので, toptree上の\u003ccode\u003eCompress/Edge Node\u003c/code\u003eが割り振られます.\n\n具体的には, 下のルールで構成します.\n\n\u003col\u003e\n\u003cli\u003eCompress Node \u003ccode\u003eab\u003c/code\u003eの左右の子が\u003ccode\u003eac\u003c/code\u003e, \u003ccode\u003ecb\u003c/code\u003eのとき, 頂点\u003ccode\u003ec\u003c/code\u003eの\u003ccode\u003ehandle\u003c/code\u003eはCompress Node \u003ccode\u003eab\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eCompress/Edge Node \u003ccode\u003eab\u003c/code\u003eの親がいない(toptreeの根): 頂点\u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003eのhandleはCompress Node\u003ccode\u003eab\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eそれ以外(Rake Treeの葉になっている): 頂点\u003ccode\u003ea\u003c/code\u003eの\u003ccode\u003ehandle\u003c/code\u003eはCompress Node \u003ccode\u003eab\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n具体例を見たほうが早い気がします.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184656.png\"  \u003e}}\n\n頂点\u003ccode\u003e0, 5\u003c/code\u003eはルール\u003ccode\u003e2.\u003c/code\u003e, \u003ccode\u003e8, a, b, c\u003c/code\u003eはルール\u003ccode\u003e3.\u003c/code\u003e, それ以外は\u003ccode\u003e1.\u003c/code\u003eです.\n\n今はとりあえずこういうものとしておくのがいいと思います.(あとで大活躍します.)\n\nまた頂点\u003ccode\u003ev\u003c/code\u003eに対して, \u003ccode\u003eN_v\u003c/code\u003eを\u003ccode\u003ev\u003c/code\u003eの\u003ccode\u003ehandle\u003c/code\u003eのNodeとします. (上の図で言えば\u003ccode\u003eN_2\u003c/code\u003eはtoptreeの根です)\n\n## Expose\n\n\u003ccode\u003eexpose\u003c/code\u003eという操作を導入したいと思います. (これが超本質)\u003cbr/\u003e\n任意の頂点\u003ccode\u003ev\u003c/code\u003eの\u003ccode\u003ehandle\u003c/code\u003eをtoptreeの根にするのが\u003ccode\u003eexpose\u003c/code\u003eです.\n\n先にどうやって\u003ccode\u003eexpose\u003c/code\u003eするか書いてしまいます.\n\n\u003ccode\u003eexpose(v)\u003c/code\u003e\n1. \u003ccode\u003eN_v\u003c/code\u003eをCompress Tree上で\u003ccode\u003esplay\u003c/code\u003eする\n2. \u003ccode\u003eN_v\u003c/code\u003eの親が\n - いない: \u003ccode\u003eN_v\u003c/code\u003eはtoptreeの根になったので\u003ccode\u003eexpose\u003c/code\u003e終了\n - Compress Node: そのCompress Nodeを\u003ccode\u003en\u003c/code\u003eとおく\n - Rake Node: そのRake Nodeを\u003ccode\u003er\u003c/code\u003eとおく, \u003ccode\u003er\u003c/code\u003eをRake Tree上で\u003ccode\u003esplay\u003c/code\u003eし, \u003ccode\u003er\u003c/code\u003eの親を\u003ccode\u003en\u003c/code\u003eとおく(\u003ccode\u003en\u003c/code\u003eはCompress Nodeになります)\n3. \u003ccode\u003en\u003c/code\u003eをCompress Tree上で\u003ccode\u003esplay\u003c/code\u003e\n4. \u003ccode\u003en\u003c/code\u003eの左のノードと\u003ccode\u003eN_v\u003c/code\u003eを入れ替える\n5. \u003ccode\u003eN_v\u003c/code\u003eがEdge Nodeのとき, \u003ccode\u003eN_v\u003c/code\u003eを\u003ccode\u003en\u003c/code\u003eにする\n6. 1に戻る.\n\n### 1. splay(N_v)\n\n\u003ccode\u003eN_v\u003c/code\u003eの属しているCompress Tree上で\u003ccode\u003eN_v\u003c/code\u003eを根にします.\n\n### 2.\n\nこれがちょっとむずかしいです.\n\n親がいない場合は目的達成なので終了です.\n\nCompress Nodeの場合, こんな状態です.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184716.png\"  \u003e}}\n\nRake Nodeの場合, 例えばこんな状態です.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184730.png\"  \u003e}}\n\n\u003ccode\u003esplay(r)\u003c/code\u003eをすると, こうなります.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184742.png\"  \u003e}}\n\n### 3. splay(n)\n\n4で行う操作を簡単にするために行います. なんで簡単になるかは\u003ccode\u003esoft_expose\u003c/code\u003eで解説したいと思います.\n\n### 4. splice(N_v)\n\n入れ替えます.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184801.png\"  \u003e}}\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184807.png\"  \u003e}}\n\n### 5.\n\nこれは何かというと, \u003ccode\u003eN_v\u003c/code\u003eがEdge Nodeのとき, \u003ccode\u003esplice\u003c/code\u003eすると\u003ccode\u003ev\u003c/code\u003eの\u003ccode\u003ehandle\u003c/code\u003eの位置が変わります. これに対応するためです.\n\n### 6.\n\nこれで, \u003ccode\u003eN_v\u003c/code\u003eをtoptreeの根にすることができます.\n\n## Soft Expose\n\n\u003ccode\u003esoft_expose\u003c/code\u003eは任意の頂点\u003ccode\u003ev\u003c/code\u003e, \u003ccode\u003ew\u003c/code\u003e間のパスのCompress Node \u003ccode\u003evw\u003c/code\u003eを作る操作です！(やっとここまできた)\u003cbr/\u003e\nこんな形にtoptreeを変形します.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190805073700.png\"  \u003e}}\n\n(8/5 なんか頭悪い画像になっていたので修正しました)\n\n手順を先に言ってしまいます\n\n\u003ccode\u003esoft_expose(v, w)\u003c/code\u003e\n1. \u003ccode\u003eexpose(v)\u003c/code\u003e\n2. \u003ccode\u003eN_v\u003c/code\u003eと\u003ccode\u003eN_w\u003c/code\u003eが\n - 同じ: toptreeの根は\u003ccode\u003evw\u003c/code\u003eか\u003ccode\u003ewv\u003c/code\u003eなので, \u003ccode\u003ewv\u003c/code\u003eであれば反転する. \u003ccode\u003esoft_expose\u003c/code\u003eおわり\n - 違う: 続く\n3. \u003ccode\u003eN_v\u003c/code\u003eをguardする(????)\n4. expose(w)\n5. \u003ccode\u003eN_v\u003c/code\u003eのguardを外す\n6. \u003ccode\u003eN_v\u003c/code\u003eから見て\u003ccode\u003eN_w\u003c/code\u003eが右側なら, 反転させる.\n7. おわり\n\ntoptreeの根をguardするとは, \u003ccode\u003esplay\u003c/code\u003e操作があってもtoptreeの根を変えさせないようにすることです.\u003cbr/\u003e\nこれは, \u003ccode\u003eN_v\u003c/code\u003eをtoptreeの根にした後, \u003ccode\u003eN_v\u003c/code\u003eの左側に\u003ccode\u003eN_w\u003c/code\u003eを持ってくる必要があり, \u003ccode\u003eN_v\u003c/code\u003eが根であり続ける必要があるからです.\n\nguardされているときの\u003ccode\u003esplice\u003c/code\u003eの操作が少し違います.\n\n\u003ccode\u003en\u003c/code\u003eの親がguardされていて, 親から見て左側にある場合, spliceは\u003ccode\u003en\u003c/code\u003eの左の子と交換しないといけません.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184839.png\"  \u003e}}\n\nしかし, 親から見て右側にある場合, spliceは\u003ccode\u003en\u003c/code\u003eの左の子と交換しないといけません.\n\n{{\u003c figure src=\"/images/2019/08/04/191420/20190804184855.png\"  \u003e}}\n\nこれはtoptreeの, 葉がパスの辺の順番になっているルールに違反するからです.(toptree壊れる)\n\n## Path Query\n\n\u003ccode\u003esoft_expose\u003c/code\u003eができるようになると, パスに関するクエリを処理することができます.\u003cbr/\u003e\nパスの長さとか, パス中の辺の長さの最大値とかです.\n\n各ノードに情報をもたせて, セグ木みたいに左の子の情報と右の子の情報を演算するみたいな感じです. これをすると, \u003ccode\u003esoft_expose(v, w)\u003c/code\u003eをして\u003ccode\u003evw\u003c/code\u003eを見た時にパス\u003ccode\u003ev-w\u003c/code\u003eについての演算結果が求まるはずです. やったね.\n\n## ひとまず終了...\n\n\u003ccode\u003elink\u003c/code\u003e, \u003ccode\u003ecut\u003c/code\u003e, \u003ccode\u003eselect\u003c/code\u003e, 各種クエリとかは後日にします... 疲れた...\n\n[Toptree - Link \u0026amp; Cut編 - niuez’s diary](https://niuez.hatenablog.com/entry/2019/08/05/114511) link cutかいた\n\n[top tree 概要 - noshi91のメモ](http://noshi91.hatenablog.com/entry/2019/08/05/175545)\n\n僕が書くのサボった厳密な話をnoshi91さんが書いています こちらも読んでください\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/entry/2019/08/05/114511":{"title":"Toptree - Link \u0026 Cut編","content":"[Toptree 導入編 - niuez’s diary](https://niuez.hatenablog.com/entry/2019/08/04/191420)\n\n引き続き, toptreeの解説をしていきます.\n\n## Link\n\n\u003ccode\u003elink(v, w)\u003c/code\u003e: 頂点\u003ccode\u003ev\u003c/code\u003eと\u003ccode\u003ew\u003c/code\u003eを辺\u003ccode\u003evw\u003c/code\u003eで結ぶをします.\n\n場合分けが多すぎるんじゃ\n\nが, \u003ccode\u003ev\u003c/code\u003eの次数が0, 1, 2以上で処理が変わり, また\u003ccode\u003ew\u003c/code\u003eの次数が0, 1, 2以上で処理が変わります. (ちなみに論文はどちらも次数2以上のときのことしか書いてない, 全部書けや)\n\nまず, \u003ccode\u003eexpose(v)\u003c/code\u003eをした結果はこんな感じに次数で場合分けできます. \u003ccode\u003eexpose\u003c/code\u003eした後, 次数1のときに右側に\u003ccode\u003ev\u003c/code\u003eが来るようにします(左にあるときはreverseします)\n\n{{\u003c figure src=\"/images/2019/08/05/114511/20190805114250.png\"  \u003e}}\n\n\u003ccode\u003eexpose(w)\u003c/code\u003eをしたときはこんな感じ. \u003ccode\u003eexpose\u003c/code\u003eした後, 次数1のときに左側に\u003ccode\u003ew\u003c/code\u003eが来るようにします.\n\n{{\u003c figure src=\"/images/2019/08/05/114511/20190805114301.png\"  \u003e}}\n\n\u003ccode\u003ev\u003c/code\u003eが右側, \u003ccode\u003ew\u003c/code\u003eが左側なのは, \u003ccode\u003e... - v\u003c/code\u003eと\u003ccode\u003ew - ...\u003c/code\u003eをつなげて \u003ccode\u003e... - v - w - ...\u003c/code\u003eとしたいからです.\n\n次に, \u003ccode\u003ew\u003c/code\u003e側のtoptreeから処理していきます.\u003cbr/\u003e\nここでは, \u003ccode\u003e... - v - w - ...\u003c/code\u003eの\u003ccode\u003ev - w - ...\u003c/code\u003eの部分を作ります.\n\n{{\u003c figure src=\"/images/2019/08/05/114511/20190805114321.png\"  \u003e}}\n\nこのそれぞれの木の根を\u003ccode\u003ev-w-\u003c/code\u003eと表すことにして,\u003cbr/\u003e\n\u003ccode\u003ev\u003c/code\u003e側のtoptreeとつなげます. つなげ方は, \u003ccode\u003ev\u003c/code\u003eの次数によって場合分けです. つなげるとこんな感じ\n\n{{\u003c figure src=\"/images/2019/08/05/114511/20190805114331.png\"  \u003e}}\n\n\u003ccode\u003e... - v - w - ...\u003c/code\u003eになっていると思います.\n\n## Cut\n\n\u003ccode\u003ecut(v, w)\u003c/code\u003e: 頂点\u003ccode\u003ev\u003c/code\u003eと\u003ccode\u003ew\u003c/code\u003eを結んでいる辺\u003ccode\u003evw\u003c/code\u003eを切ります\n\n\u003ccode\u003elink\u003c/code\u003eの逆操作をすればいいです.\n\u003ccode\u003esoft_expose\u003c/code\u003eを思い出してみましょう.\n\n{{\u003c figure src=\"/images/2019/08/05/114511/20190805073700.png\"  \u003e}}\n\n\u003ccode\u003evw\u003c/code\u003eは辺なので, 図中の丸\u003ccode\u003evw\u003c/code\u003eはCompress Nodeではなく, Edge Nodeのはずです.\nまた, \u003ccode\u003edegree(v) \u003e= 2, degree(w) \u003e= 2\u003c/code\u003eのパターンを見ると, \u003ccode\u003eN_w\u003c/code\u003e以下が\u003ccode\u003elink\u003c/code\u003eでの\u003ccode\u003ev - w - ...\u003c/code\u003eの部分を作るときと形が同じです.\u003cbr/\u003e\nまあなので逆操作をすると\u003ccode\u003ecut\u003c/code\u003eができます.\n\n## 記事を分けたの失敗\n\nLinkとCut重いなあと違う記事にしたけど, 図を作ったらそんなに重くなかった\n\n次はクエリの捌き方を書きます(これは流石に分けないとまずい)\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/entry/2019/10/05/002503":{"title":"BFS Numbering","content":"僕が木上クエリコンで出題した問題で使った手法です.\n\n[No.899 γatheree - yukicoder](https://yukicoder.me/problems/no/899)\n\n## アルゴリズム\n\n例\n\n{{\u003c figure src=\"/images/2019/10/05/002503/20191005001432.png\"  \u003e}}\n\nBFSを行って頂点に番号を順番に振っていきます.\n\n```\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14\n```\n\n\nになります. ここで, BFSは深さが浅い順に頂点を見ることに注目すると,\n\n\u003cul\u003e\n\u003cli\u003e頂点0の部分木の中で, 頂点0から距離1にある頂点\u003c/li\u003e\n\u003c/ul\u003e\n\n\n```\n0 [1 2] 3 4 5 6 7 8 9 10 11 12 13 14\n```\n\n\n\u003cul\u003e\n\u003cli\u003e頂点0の部分木の中で, 頂点0から距離2にある頂点\u003c/li\u003e\n\u003c/ul\u003e\n\n\n```\n0 1 2 [3 4 5 6] 7 8 9 10 11 12 13 14\n```\n\n\nまた同様に\n\n\u003cul\u003e\n\u003cli\u003e頂点1の部分木の中で, 頂点0から距離1にある頂点\u003c/li\u003e\n\u003c/ul\u003e\n\n\n```\n0 1 2 [3 4] 5 6 7 8 9 10 11 12 13 14\n```\n\n\n\u003cul\u003e\n\u003cli\u003e頂点1の部分木の中で, 頂点0から距離2にある頂点\u003c/li\u003e\n\u003c/ul\u003e\n\n\n```\n0 1 2 3 4 5 6 [7 8 9 10] 11 12 13 14\n```\n\n\nつまりBFS Numberingは, 深さを同じくする頂点を列の区間に落とし込むことができます.\n\n実装はこんな感じ(この例では, 距離2までの頂点を記録しています)\n\n```cpp\ni64 N;\ncin \u003e\u003e N;\nidx.resize(N + 1, -1);//idx[v] := Euler Tourの列での頂点vの位置\nL1.resize(N + 1, -1);//距離1にある頂点の列の左端\nR1.resize(N + 1, -1);//右端\nL2.resize(N + 1, -1);//距離2にある頂点の列の左端\nR2.resize(N + 1, -1);//右端\np.resize(N + 1, -1);//親\nG.resize(N + 1);\nfor(int i = 0;i \u0026lt; N - 1; i++) {\n  i64 a, b;\n  cin \u003e\u003e a \u003e\u003e b;\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nG[N].push_back(0);\n\nqueue\u0026lt;i64\u003e que;\nque.push(N);\nidx[N] = vec.size();\nvec.push_back(N);\nwhile(!que.empty()) {\n  i64 v = que.front();\n  que.pop();\n  for(auto x: G[v]) {\n    if(idx[x] != -1) continue;\n    que.push(x);\n    idx[x] = vec.size();\n    vec.push_back(x);\n    p[x] = v;\n\n    if(L1[v] == -1) L1[v] = idx[x];\n    R1[v] = idx[x] + 1;\n\n    i64 pp = p[v];\n    if(pp != -1) {\n      if(L2[pp] == -1) L2[pp] = idx[x];\n      R2[pp] = idx[x] + 1;\n    }\n  }\n}\n\n```\n\n\nわりと素直に書ける\n\n## 感想\n\n新出で驚いた 典型にしていこうな\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/entry/2019/12/14/000036":{"title":"動的木上の最小シュタイナー木をtoptreeで解く","content":"この記事は\u003ca href=\"https://qiita.com/advent-calendar/2019/str\"\u003e「データ構造とアルゴリズム Advent Calendar 2019」\u003c/a\u003e 14日目の記事です.\u003cbr/\u003e\n13日目は\u003ca href=\"https://qiita.com/ajalab\"\u003e@ajalab\u003c/a\u003eさんの\u003ca href=\"https://scrapbox.io/koki/Run-Length_FM-Index\"\u003eRun-Length FM-Index - koki\u003c/a\u003e,\u003cbr/\u003e\n15日目は\u003ca href=\"https://qiita.com/minaminao\"\u003e@minaminao\u003c/a\u003eさんのMerkle Patricia Tree まわりです.\n\n## toptreeとは\n\ntoptreeは今年競プロ界隈で話題になった動的木を扱うデータ構造の一つです.\u003cbr/\u003e\nlink-cut treeも同じ動的木を扱うデータ構造ですが, 機能だけを見ればその完全上位互換です.\n\ntoptreeは, 木を動的に扱うデータ構造です. \u003ca href=\"https://arxiv.org/abs/cs/0310065\"\u003e[cs/0310065] Maintaining Information in Fully-Dynamic Trees with Top Trees\u003c/a\u003eを読みました.\n\ntoptree自体については半年くらい前に自分が書いた記事があります.\n\n[Toptree 導入編 - niuez’s diary](https://niuez.hatenablog.com/entry/2019/08/04/191420)\n\n上の記事をまとめると\n\n\u003cul\u003e\n\u003cli\u003e基本的には, 平衡二分探索木(Splay Tree)\u003c/li\u003e\n\u003cli\u003e葉には辺を表すノード(Edge Node)\u003c/li\u003e\n\u003cli\u003e1頂点を共有する２つの辺をマージして新しくできた辺を平衡二分探索木の節とする(Compress \u0026amp; Rake)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20190804184203.png\"  \u003e}}\n\n\u003cul\u003e\n\u003cli\u003e二分木だけでは列しか管理できないので, 二分木ともう一つの子を管理する(Rake Node)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20190804184342.png\"  \u003e}}\n\nというあたりです.\nこの形を保持しながらsplay treeの回転を行い各クエリの計算量を償却$ O(\\log N)$を達成しています.\n\n例えば,\n\n\u003cul\u003e\n\u003cli\u003e$ \\mathtt{link}$: ある2頂点間を辺で結ぶ\u003c/li\u003e\n\u003cli\u003e$ \\mathtt{cut}$: ある2頂点間を結んでいる辺をなくす\u003c/li\u003e\n\u003cli\u003eパス: ある木の2頂点を結ぶパスについてのクエリを処理する\n\n\u003cul\u003e\n\u003cli\u003e辺の重みの総和\u003c/li\u003e\n\u003cli\u003e辺の重みを$ +x$する\u003c/li\u003e\n\u003cli\u003eなど...\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e木全体に対するクエリ\n\n\u003cul\u003e\n\u003cli\u003e木に含まれる辺の重みを$ +x$する\u003c/li\u003e\n\u003cli\u003e木の頂点の重みの総和\u003c/li\u003e\n\u003cli\u003e木の直径\u003c/li\u003e\n\u003cli\u003eある頂点からの最遠点距離\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003etoptree上の二分探索\n\n\u003cul\u003e\n\u003cli\u003e木の中心\u003c/li\u003e\n\u003cli\u003e木の重心\u003c/li\u003e\n\u003cli\u003eパス$ x, \\cdots, y$上で$ x$から$ y$に向かって$ d$だけ進んだ場所にある頂点 \u003ca href=\"#f-8d0d75ed\" name=\"fn-8d0d75ed\" title=\" jumpと呼ばれることが多い \"\u003e*1\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\nというクエリが処理できます. 最強っぽい.\n\nこれを実装したのがこれです. めっちゃ大変でした. \u003ca href=\"https://github.com/niuez/toptree-rust\"\u003eniuez/toptree-rust\u003c/a\u003e\n\n## 動的木上の最小シュタイナー木\n\n10月に僕の作問した問題がyukicoderで木上クエリコンとして出題されました. このときに全問正解を(意図的に)阻止した問題がこれです.\n\n[No.902 Query ζone - yukicoder](https://yukicoder.me/problems/no/902)\n\n辺に正の重みが与えられている木の形が動的に変わっていくなかで, 頂点$ v_0, \\cdots, v_{k-1}$の最小シュタイナー木の重みを答えるクエリを処理しなければなりません.\n\nサンプルを図にしてみます.\n\nサンプルの2個目のクエリのとき, 木は以下のような形をしています. この木に関して, 頂点0, 4, 6を頂点の部分集合とする最小シュタイナー木の重みは20です.\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211212237.png\"  \u003e}}\n\nサンプルの4個目のクエリのとき, 木は以下のような形をしています. この木に関して, 頂点0, 4, 6を頂点の部分集合とする最小シュタイナー木の重みは27です.\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211212246.png\"  \u003e}}\n\nこの問題は, toptreeに載せることで解くことができます. 今回はその解説をしたいと思います.\n\nここから先, 各クエリで最小シュタイナー木に含めなければならない頂点を\u003cstrong\u003e赤い頂点\u003c/strong\u003eと表現することにします.\n\n## アルゴリズム\n\ntoptreeでは上でも述べたように, \u003cstrong\u003e1頂点を共有する２つの辺をマージして新しくできた辺\u003c/strong\u003eを平衡二分探索木の節とします.\u003cbr/\u003e\n今回の問題で考えられる, マージされる前の辺の状態は2通りのみです.\n\n\u003cul\u003e\n\u003cli\u003e赤い頂点を1個以上含んでマージされた辺\u003c/li\u003e\n\u003c/ul\u003e\n\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211215436.png\"  \u003e}}\n\n\u003cul\u003e\n\u003cli\u003e赤い頂点を一度も含んでいない辺\u003c/li\u003e\n\u003c/ul\u003e\n\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211215446.png\"  \u003e}}\n\n以下のような場合を考えそうになりますが, これは$ \\mathbb{inter}=0$とすると, １つ目のパターンと同じになります.\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211215846.png\"  \u003e}}\n\n辺の端点の色は, マージするときに考えます. つまり, マージの方法は\n左側の辺の状態(2通り) * 右側の辺の状態(2通り) * 共有している1頂点の色(2通り) = 8通りです\n\n## マージの計算方法(Compress)\n\n以下の通りです.\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211223455.png\"  \u003e}}\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211223522.png\"  \u003e}}\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211223533.png\"  \u003e}}\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211223543.png\"  \u003e}}\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211223554.png\"  \u003e}}\n\nこのパターンは頂点が赤でも黒でも同じです\n\n## 何か足りない\n\nこのパターンだけでは, $ \\mathbb{inter}$は作られません. どういうことでしょう...?\u003cbr/\u003e\n上でも述べたとおり, toptreeでは2通りのマージ方法があります. そのもう一つのマージ方法(\u003cstrong\u003eRake\u003c/strong\u003e)では以下のパターンで$ \\mathbb{inter}$を発生させます.\n\n{{\u003c figure src=\"/images/2019/12/14/000036/20191211224305.png\"  \u003e}}\n\n他のパターンは上と同じように計算することができます.\n\nこれをちゃんと実装すると以下のように解くことができます.\n\n[#383717 No.902 Query ζone - yukicoder](https://yukicoder.me/submissions/383717)\n\n20行目からの関数が, 上で述べたCompressのマージの計算をしています. その下にRakeの計算もありますね.\n\n## しめ\n\n今年はtoptreeに夢中な一年でした. 来年はどうなるでしょうか.\n\u003cdiv class=\"footnote\"\u003e\n\u003ca href=\"#fn-8d0d75ed\" name=\"f-8d0d75ed\" class=\"footnote-number\"\u003e*1\u003c/a\u003e\u003cspan class=\"footnote-delimiter\"\u003e:\u003c/span\u003e\u003cspan class=\"footnote-text\"\u003e jumpと呼ばれることが多い \u003c/span\u003e\n\u003c/div\u003e\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/entry/2019/12/16/203739":{"title":"Suffix Array と LCP と 文字列検索の実装をした","content":"この土日のメモです. SAとLCPのお気持ちをまとめたくなっただけ. 間違ってたらごめん\n\n\u003e文字列アルゴの勉強する気が起きないたった一つの理由: Rolling Hash— νιυεζ (@xiuez) 2019年12月13日\u003cscript async=\"\" src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"\u003e\u003c/script\u003e\n\nこれをやめたいので, 手始めにSuffix Arrayを使った文字列検索をやってみようかなというのが今回の主題\n\n## 概要\n\n\u003cul\u003e\n\u003cli\u003eSA-ISでSuffix Arrayを構築$ O(|S|)$\u003c/li\u003e\n\u003cli\u003eLCP配列の構築$ O(|S|)$\u003c/li\u003e\n\u003cli\u003eLCPによるSuffix同士のLCPをSparse Tableで構築$ O(|S| \\log{|S|})$, クエリ$ O(1)$\u003c/li\u003e\n\u003cli\u003eSuffix Arrayの二分探索で文字列検索を$ O(|T| log{|S|})$\u003c/li\u003e\n\u003cli\u003eSuffix ArrayとLCPの二分探索で文字列検索を構築$ O(|S|)$, クエリ$ O(|T| + \\log{|S|})$\u003c/li\u003e\n\u003c/ul\u003e\n\n\nの実装をやってみました. このときのメモを残しておきたいと思います.\n\n各用語の説明はここではしません... 他の記事や, \u003ca href=\"https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%82%B3%E3%83%B3%E3%83%86%E3%82%B9%E3%83%88%E3%83%81%E3%83%A3%E3%83%AC%E3%83%B3%E3%82%B8%E3%83%96%E3%83%83%E3%82%AF-%E7%AC%AC2%E7%89%88-%EF%BD%9E%E5%95%8F%E9%A1%8C%E8%A7%A3%E6%B1%BA%E3%81%AE%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E6%B4%BB%E7%94%A8%E5%8A%9B%E3%81%A8%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF%E3%82%92%E9%8D%9B%E3%81%88%E3%82%8B%EF%BD%9E-%E7%A7%8B%E8%91%89%E6%8B%93%E5%93%89/dp/4839941068\"\u003e蟻本 - Amazon\u003c/a\u003eを参考に.\n\n## SA-IS\n\nSuffix Arrayの実装は蟻本にも載っていますが, そこまで早くありません... SA-ISというアルゴリズムが早いらしいのでこれを実装します.\n\nSA-ISの理解には, この記事がとても参考になりました. とてもわかりやすい記事です.\n\n[ SA-IS 法のメモ - まめめも](https://mametter.hatenablog.com/entry/20180130/p1)\n\nSA-ISの実装は\u003ca href=\"https://judge.yosupo.jp/submission/1069\"\u003eyosupoさんのコード\u003c/a\u003eを見ました.\n\n僕が書いたSA-ISのコードはこれです.\n\n[Submitted](https://judge.yosupo.jp/submission/1908)\n\n\u003cul\u003e\n\u003cli\u003eメモリを使い回す(resizeの回数を減らしてメモリを使いまわしても, assignが割と早くてこれが非自明)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epush_back\u003c/code\u003eをなくす\u003c/li\u003e\n\u003cli\u003e入出力の早いライブラリを使うともっと早くなります\u003c/li\u003e\n\u003c/ul\u003e\n\n\n実はSA-ISの論文に実装が載っていてそれがとても速いです. ぜひ参考にしてみてください.\n\n以下, 文字列\u003ccode\u003eS\u003c/code\u003eのSuffix Arrayを\u003ccode\u003eSA\u003c/code\u003eとします. \u003ccode\u003eS\u003c/code\u003eの辞書順で\u003ccode\u003ei\u003c/code\u003e番目に小さいsuffixを\u003ccode\u003eSuf[i] := S[SA[i]...]\u003c/code\u003eとします.\n\n## LCP(Longest Common Prefix)\n\nLCP配列は, Suffix Arrayで隣り合ったSuffix(つまり, \u003ccode\u003eSuf[i]とSuf[i + 1]\u003c/code\u003e)の最長共通接頭辞を求めた配列です. Kasai\u0026#39;s Algorithmを用いて$ O(|S|)$で構築できます.\n\nLCPの理解は以下の記事がわかりやすいです. 蟻本にもあるはず.\n\n[LCP配列 (Kasai’s algorithm)](https://lumakernel.github.io/ecasdqina/string/LCP-Array)\n\n例は,\n\u003ca href=\"https://ei1333.github.io/luzhiled/snippets/string/suffix-array.html\"\u003e接尾辞配列(Suffix-Array) | Luzhiled’s memo\u003c/a\u003e がわかりやすいです.\n\n僕の実装は先頭に無(空配列)があるので, 以下のようになります.\n\n```\ni :lcp\n0 : 0 \n1 : 0 a\n2 : 1 abra\n3 : 4 abracadabra\n4 : 1 acadabra\n5 : 1 adabra\n6 : 0 bra\n7 : 3 bracadabra\n8 : 0 cadabra\n9 : 0 dabra\n10: 0 ra\n11: 2 racadabra\n```\n\n\n## 任意のsuffix同士のLCP\n\n上の例で, \u003ccode\u003ei = 2, abra\u003c/code\u003eと, \u003ccode\u003ej = 5, adabra\u003c/code\u003eのLCPを求めるとすると, \u003ccode\u003e3, 4, 5\u003c/code\u003eの\u003ccode\u003elcp\u003c/code\u003eの最小値である\u003ccode\u003e1\u003c/code\u003eがその答えになります.\n\nSuffix Arrayで, indexが $ i$ のsuffixと $ j$ のsuffixのLCPは, $ [i + 1, j + 1)$ 間の\u003ccode\u003elcp\u003c/code\u003eの最小値になります.\n\nなので, \u003ccode\u003elcp\u003c/code\u003eをSparse Tableに載せると構築 $ O(|S| \\log{|S|})$, クエリ$ O(1)$で処理できます.\n\n## Suffix Arrayで文字列検索\n\n文字列\u003ccode\u003eS\u003c/code\u003eのSuffix Array \u003ccode\u003eSA\u003c/code\u003eを使って, \u003ccode\u003eS\u003c/code\u003eの中に文字列\u003ccode\u003eT\u003c/code\u003eがあるかどうかを二分探索で処理できます. これは, Suffix Arrayによって各suffixがソートされているのを利用しています.\n\n計算量は$ O(|T| \\log{|S|})$です. \u003ca href=\"https://onlinejudge.u-aizu.ac.jp/status/users/niuez/submissions/1/ALDS1_14_D/judge/4048844/C++14\"\u003eAOJの提出コード\u003c/a\u003e\n\n```cpp\ncin \u003e\u003e t;\nint L = 0;\nint R = sa.size();\nwhile(R - L \u003e 1) {\n  int M = (L + R) \u003e\u003e 1;\n  if(s.substr(sa[M], t.size()) \u0026lt;= t) {\n    L = M;\n  }\n  else {\n    R = M;\n  }\n}\ncout \u0026lt;\u0026lt; (s.substr(sa[L], t.size()) == t) \u0026lt;\u0026lt; endl;\n\n```\n\n\nこれがかなりはやい なんでだろう\n\n## SAとLCPで文字列検索\n\nこの二分探索はさらに高速化できます. suffixとTの比較を最小限にすることで, $ O(|T| + \\log{|S|})$を達成します.\n\n具体的には, \u003ccode\u003esuf[L]\u003c/code\u003eとTのLCPを常に持ちながら二分探索をします. このLCPを\u003ccode\u003eLlcp\u003c/code\u003eとします.  \u003ccode\u003eM = (L + R) / 2\u003c/code\u003eとして, \u003ccode\u003esuf[L]\u003c/code\u003eと\u003ccode\u003esuf[M]\u003c/code\u003eのLCPを求めて, \u003ccode\u003enlcp\u003c/code\u003eとします. \u003ccode\u003enlcp\u003c/code\u003eは先に書いたとおり, Sparse Tableで求めることができます.  次に\u003ccode\u003eLlcp\u003c/code\u003eと\u003ccode\u003enlcp\u003c/code\u003eを比較します.\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eLlcp \u0026lt; nlcp\u003c/code\u003e\u003c/strong\u003eのとき\u003c/li\u003e\n\u003c/ul\u003e\n\n\n以下の例で考えてみます. (Suffix Arrayではありませんが, 複数の文字列を辞書順にソートしたという意味で同じです)\n\n```\nT = ad\n\nL : aaa\n    aaab\n    aaac\nM : aac\n    aacc\n    ba\nR : \n\nLlcp = LCP(aaa, ad) = 1  // \"a\"aa, \"a\"dなので\nnlcp = LCP(aaa, aac) = 2 // \"aa\"a, \"aa\"cなので\n```\n\n\n\u003ccode\u003eT\u003c/code\u003eは辞書順で\u003ccode\u003esuf[T]\u003c/code\u003e以上ということがわかっているので, \u003ccode\u003eLlcp \u0026lt; nlcp\u003c/code\u003eより, Tと\u003ccode\u003esuf[M]\u003c/code\u003eのLCPは\u003ccode\u003eLlcp\u003c/code\u003eであり, \u003ccode\u003eT\u003c/code\u003eは辞書順で\u003ccode\u003esuf[M]\u003c/code\u003e以上です.  なので, Llcpはそのままで, \u003ccode\u003eL = M\u003c/code\u003eとします.\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eLlcp \u003e nlcp\u003c/code\u003e\u003c/strong\u003eのとき\u003c/li\u003e\n\u003c/ul\u003e\n\n\n```\nT = aaac\n\nL : aaa\n    aaab\n    aaac\nM : aac\n    aacc\n    ba\nR : \n\nLlcp = LCP(aaa, aaac) = 3  // \"aaa\", \"aaa\"cなので\nnlcp = LCP(aaa, aac) = 2 // \"aa\"a, \"aa\"cなので\n```\n\n\nT\u003ccode\u003eと\u003c/code\u003esuf[M]\u003ccode\u003eのLCPは\u003c/code\u003enlcp\u003ccode\u003eであり,\u003c/code\u003eT\u003ccode\u003eは辞書順で\u003c/code\u003esuf[M]\u003ccode\u003e未満です. なので, Llcpはそのままで,\u003c/code\u003eR = M`とします.\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eLlcp = nlcp\u003c/code\u003e\u003c/strong\u003eのとき\u003c/li\u003e\n\u003c/ul\u003e\n\n\n```\nT = aacc\n\nL : aaa\n    aaab\n    aaac\nM : aac\n    aacc\n    ba\nR : \n\nLlcp = LCP(aaa, aacc) = 2  // \"aa\"a, \"aa\"ccなので\nnlcp = LCP(aaa, aac) = 2 // \"aa\"a, \"aa\"cなので\n```\n\n\nこのときは, \u003ccode\u003eT\u003c/code\u003eと\u003ccode\u003esuf[M]\u003c/code\u003eの辞書順の関係がわからないので比較をします. このとき, \u003cstrong\u003eLCPの部分は一致していることがわかっているので比較をしなくてよい\u003c/strong\u003eです. 比較をした後, Llcpを比較をした時の計算結果を利用して更新します.\n\n\u003ccode\u003eLlcp\u003c/code\u003eは探索中, 単調増加します. なので, 文字列の比較が全体で$ O(|T|)$しかされません. これにより, 計算量が改善されます.\n\n実際にコードを示します.\n\n```cpp\nstd::pair\u0026lt;int, int\u003e get_lcp(const std::vector\u0026lt;T\u003e\u0026amp; t, int si, int offset) {\n  int i = offset;\n  si += offset;\n  while(i \u0026lt; t.size() \u0026amp;\u0026amp; si \u0026lt; N) {\n    if(t[i] != str[si]) {\n      return { i, t[i] - str[si] };\n    }\n    i++;\n    si++;\n  }\n  return { i, 0 };\n}\n\nstd::pair\u0026lt;int, int\u003e search(const std::vector\u0026lt;T\u003e\u0026amp; t) {\n  int L = 0;\n  int R = N + 1;\n  int Llcp = 0;\n\n  while(R - L \u003e 1) {\n    int M = (L + R) \u003e\u003e 1;\n    int nlcp = st.query(L + 1, M + 1);\n    if(Llcp \u0026lt; nlcp) {\n      L = M;\n    }\n    else if(Llcp \u003e nlcp) {\n      R = M;\n    }\n    else {\n      auto p = get_lcp(t, sa[M], Llcp);\n      if(p.second \u003e= 0) {\n        L = M;\n        Llcp = p.first;\n      }\n      else if(p.second \u0026lt; 0) {\n        R = M;\n      }\n    }\n  }\n\n  return { Llcp, L };\n}\n\n```\n\n\nこれで早くなるはず...!\n\n[Aizu Online Judge](https://onlinejudge.u-aizu.ac.jp/status/users/niuez/submissions/2/ALDS1_14_D/judge/4048629/C++14)\n\n5倍遅くなった...\n\n## Sparse Tableの構築が重すぎる\n\n$ O(|S| \\log{|S|})$ 流石に重い... 改善したい\n\n## Sparse Tableを使わない方法で改善\n\n二分探索だけならSparse Tableである必要はありません. Segment Treeを使います.\u003cbr/\u003e\n二分探索で最小値を求めたい区間は必ず\u003ccode\u003e[L, (L + R) / 2)\u003c/code\u003eに対応できます. なので, 二分探索するときに, Segment Treeのノードを降りていくようにすると 構築$ O(|S|)$で二分探索ができるようになります.\n\nコードはこんな感じ\n\n```cpp\n...\n...\n  seg_n = 1;\n  while(seg_n \u0026lt; N + 1) seg_n \u0026lt;\u0026lt;= 1;\n  seg.resize(seg_n * 2, 1e9);\n  for(int i = 0;i + 1 \u0026lt; N + 1;i++) {\n    seg[i + seg_n - 1] = lcp[i + 1];\n  }\n  for(int i = seg_n - 1; i --\u003e 0;) {\n    seg[i] = std::min(seg[(i \u0026lt;\u0026lt; 1) + 1], seg[(i \u0026lt;\u0026lt; 1) + 2]);\n  }\n}\n\nstd::pair\u0026lt;int, int\u003e get_lcp(const std::vector\u0026lt;T\u003e\u0026amp; t, int sa_i, int offset) {\n  if(sa_i \u003e N) return { offset, -1 };\n  int i = offset;\n  int si = sa[sa_i] + offset;\n  while(i \u0026lt; t.size() \u0026amp;\u0026amp; si \u0026lt; N) {\n    if(t[i] != str[si]) {\n      return { i, t[i] - str[si] };\n    }\n    i++;\n    si++;\n  }\n  return { i, 1 };\n}\n\nstd::pair\u0026lt;int, int\u003e search(const std::vector\u0026lt;T\u003e\u0026amp; t) {\n  int L = 0;\n  int R = seg_n;\n  int Llcp = 0;\n  int j = 0;\n\n  while(R - L \u003e 1) {\n    int M = (L + R) \u003e\u003e 1;\n    int nlcp = seg[(j \u0026lt;\u0026lt; 1) + 1];\n    if(nlcp == 1e9) {\n      j = (j \u0026lt;\u0026lt; 1) + 1;\n      R = M;\n    }\n    else if(Llcp \u0026lt; nlcp) {\n      j = (j \u0026lt;\u0026lt; 1) + 2;\n      L = M;\n    }\n    else if(Llcp \u003e nlcp) {\n      j = (j \u0026lt;\u0026lt; 1) + 1;\n      R = M;\n    }\n    else {\n      auto p = get_lcp(t, M, Llcp);\n      if(p.second \u003e= 0) {\n        j = (j \u0026lt;\u0026lt; 1) + 2;\n        L = M;\n        Llcp = p.first;\n      }\n      else if(p.second \u0026lt; 0) {\n        j = (j \u0026lt;\u0026lt; 1) + 1;\n        R = M;\n      }\n    }\n  }\n\n  return { Llcp, L };\n}\n\n```\n\n\n[Aizu Online Judge](https://onlinejudge.u-aizu.ac.jp/status/users/niuez/submissions/1/ALDS1_14_D/judge/4050033/C++14)\n\nこれでも最初の二分探索に勝てませんでした... なんでだろう でもこれでもかなり速いです.\n\n## しめ\n\nFM-indexとかやってみたくなりました\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/first":{"title":"First","content":"\nはじめまして\n\nいつはてなブログが消えてもおかしくない気がするので, [僕のはてなブログ](https://niuez.hatenablog.com/)からこっちに移してこようかなと考えてます.  \nテスト期間真っ最中なので春休みに入ったらやろうかな.\n\nにう\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/fps-newton":{"title":"FPSのニュートン法メモ","content":"\nFPSのライブラリ書き直しに合わせて、[ABC222 H - Beautiful Binary Tree](https://atcoder.jp/contests/abc222/tasks/abc222_h)のニュートン法解(TLE)でニュートン法の勉強をしてみました. [nyaanさんのライブラリ](https://nyaannyaan.github.io/library/fps/formal-power-series.hpp.html)に仕組みが書いてあるのでこれを読みました\n\n$$\nG(\\hat{g}) \\equiv f \\pmod{x^n} \\\\\\\\\ng \\equiv \\hat{g} - \\frac{G(\\hat{g}) - f}{G'(\\hat{g})} \\pmod{x^{2n}}\n$$\n\nを使って、$n=1$の初期値から帰納的に計算します。\n\nABC222Hでは答えの母関数を$A$とすると、\n\n$$\nA = x (1 + 3 A + A^2)^2\n$$\n\nAを求めたいので、変形して\n\n$$\nG(A) = \\frac{A}{(1 + 3 A + A^2)^2} = x = f\n$$\n\n$$\nG'(A) = \\frac{1 - 3A - 3 A^2}{(1 + 3A + A^2)^3} \\\\\\\\\nA - \\frac{G(A) - f}{G'(A)} = A - \\frac{(1 + 3A + A^2)(A - x(1 + 3A + A^2)^2)}{1 - 3A - 3A^2}\n$$\n\n各段階の計算は$O(n \\log n)$なので、全体でも$O(N \\log N)$です。この問題だと間に合わないけど、どこかで使えそうだね。\n\n[提出コード](https://atcoder.jp/contests/abc222/submissions/30965301)\n\n```cpp\ni64 N;\ncin \u003e\u003e N;\n\nfps A({ fp(0) });\nfps E({ fp(1) });\nE.resize(bound_pow2(N + 1));\nint en = E.size();\nauto de = std::move(E).dft(E.size());\nwhile(A.size() \u003c= N) {\n  i64 n = A.size();\n  auto da = A.clone().dft(n * 4);\n  fps::DFT da2(vector\u003cfp\u003e(n * 2));\n  rep(i,0,n * 2) {\n    da2[i] = da[i * 2] * da[i * 2];\n  }\n  auto db = da2;\n  i64 diff = de.size() / db.size();\n  rep(i,0,db.size()) {\n    db[i] += da[i * 2] * fp(3) + de[i * diff];\n  }\n  auto B = std::move(db).idft();\n  db = std::move(B).dft(n * 4);\n  auto B2 = (db * db).idft(2 * n);\n  for(int i = B2.size(); i --\u003e 1;) {\n    B2[i] = B2[i - 1];\n  }\n  B2[0] = fp(0);\n  B2.resize(4 * n);\n  auto C = std::move(db *= (da - std::move(B2).dft(n * 4))).idft(2 * n);\n  C.resize(4 * n);\n  \n  auto dd = da2;\n  rep(i,0,dd.size()) {\n    dd[i] = dd[i] * fp(3) + da[i * 2] * 3;\n  }\n  auto D = std::move(dd).idft();\n  D[0] -= fp(1);\n  auto iD = D.inv(2 * n);\n  A.resize(2 * n);\n  A += (std::move(C).dft(4 * n) * std::move(iD).dft(4 * n)).idft(2 * n);\n}\ncout \u003c\u003c A[N] \u003c\u003c endl;\n```\n\n~~にうとんほう~~\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/fully_retroactive_stack":{"title":"Fully Retroactive Stack 実装してみた","content":"\nnoshi91さんがFully Retroactive Stackについての解説生放送をやっていたので, その解説通りに実装してみました. ちょっとした解説も書きました.\n\n## できること\n\nStackの処理できるクエリは以下の通りです.\n\n- $\\mathtt{push}(x)$: 要素 $x$ を列の後ろに追加する.\n- $\\mathtt{pop}()$: 列の一番後ろの要素を取り出す.\n- $\\mathtt{top}()$: 列の後ろの要素を求める.\n\nこれをFully Retroactive Stackに進化させると, こんな感じ.\n\n- $\\mathtt{insert}(t, \\mathtt{Query})$: 時刻$t$に$\\mathtt{Query}$があったとにする.(過去改変)\n- $\\mathtt{delete}(t)$: 時刻$t$のクエリを無かったことにする.(過去改変)\n- $\\mathtt{top}(t)$: 時刻$t$時点で$\\mathtt{top}()$をしたときの値を求める.\n\nこれを$O(\\log N)$($N$は$\\mathtt{Query}$数)でします.\n\n実は, 今回実装するFully Retroactive Stackは, Stack Arrayとして処理できます. つまり, $\\mathtt{top}$よりも強い$\\mathtt{at}$が処理できます. これは後ほど.\n\n## アルゴリズム\n\n$\\mathtt{push}$と$\\mathtt{pop}$をしたときの時系列とStackのサイズをグラフにすると, 例えばこのようになります.\n\n![](/images/FR_Stack/graph1.png)\n\n`A`の時点では, Stackは`[1, 2]`の状態, `B`の時点では, Stackは`[1, 4]`の状態です. こんな感じ.\n\n![](/images/FR_Stack/graph2.png)\n![](/images/FR_Stack/graph3.png)\n\nこうみると, 最後に高さ$i$を通過した$\\mathtt{push}$が, Stackの$i$番目の要素となります. これを探索できれば勝ちです.\n\nこれは, 二分探索で探すことができます. 実際に, `B`の時点での$\\mathtt{top}$つまり, 高さ$2$の$\\mathtt{push}$を探すことにします.\n\nまず真ん中で区切り, 左右の**最低高度**と**最高高度**を調べます. もし右側の最低高度と最高高度の区間に, 求めたい高さが存在すれば右側を探索します. 逆に存在しなければ, 左側を探索します.\n\n![](/images/FR_Stack/search1.png)\n\n右側が含んでいるので, 右に進みます.\n\n![](/images/FR_Stack/search2.png)\n\n右側が含んでいないので, 左に進みます.\n\n![](/images/FR_Stack/search3.png)\n\n右側が含んでいるので, 右に進みます. すると, $\\mathtt{push}(4)$にたどり着きます. これが, `B`の時点での$\\mathtt{top}$です. これを考えると, $\\mathtt{at}$も処理できそうですね.\n\n`A`の時点での$\\mathtt{top}$を調べたいなら, `A`までの区間で探索を開始すればよいです.\n\n## 実装に必要なデータ構造\n\nつまり, \n\n- 操作の挿入, 削除をする.\n- 操作を`split`, `merge`したい.\n- 二分探索がしたい.\n\nので, 操作(グラフでいう, 矢印)を葉に持つ平衡二分探索木を書けば良さそうです.\n\n## 罠\n\n何も入っていないStackを$\\mathtt{pop}$すると,`None`を返すような仕様の場合, 上の方法のままだとうまく探索できません. 本来は, サイズが$0$から$0$に遷移するが, グラフのままだと, サイズが$0$から$-1$になってしまいます.\n\nこれは, 探索を行う前に最低高度まで潜っておくことで解決できます. こんな感じ.\n\n\u003cblockquote class=\"twitter-tweet\" data-partner=\"tweetdeck\"\u003e\u003cp lang=\"und\" dir=\"ltr\"\u003e\u003ca href=\"https://t.co/7YoTD6hftP\"\u003epic.twitter.com/7YoTD6hftP\u003c/a\u003e\u003c/p\u003e\u0026mdash; Niuez (@xiuez) \u003ca href=\"https://twitter.com/xiuez/status/1248253868384768000?ref_src=twsrc%5Etfw\"\u003eApril 9, 2020\u003c/a\u003e\u003c/blockquote\u003e\n\u003cscript async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"\u003e\u003c/script\u003e\n\n## 実装\n\n親ありmerge/split型AVL葉木です...\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003ccassert\u003e\n\nstruct retroactive_stack {\n  using value_type = long long;\n  using size_type = std::size_t;\n  using height_type = std::int_least32_t;\n  using node_index = std::int_least32_t;\n\n  struct diff {\n    value_type p_value;\n    height_type d;\n    height_type max_d;\n    height_type min_d;\n\n    static diff push_diff(value_type value) {\n      diff i;\n      i.p_value = value;\n      i.d = 1;\n      i.max_d = 1;\n      i.min_d = 0;\n      return i;\n    }\n    static diff pop_diff() {\n      diff i;\n      i.d = -1;\n      i.max_d = 0;\n      i.min_d = -1;\n      return i;\n    }\n\n    static diff ope(const diff\u0026 l, const diff\u0026 r) {\n      diff i;\n      i.d = l.d + r.d;\n      i.max_d = std::max(l.max_d, l.d + r.max_d);\n      i.min_d = std::min(l.min_d, l.d + r.min_d);\n      return i;\n    }\n  };\n\n  struct node;\n\n  static struct node n[2020202];\n  static size_type ni;\n\n  struct node {\n    diff d;\n    size_type s;\n    height_type h;\n    node_index c[2];\n    node_index p;\n    node() {}\n    node\u0026 operator[](size_type d) { return n[c[d]]; }\n  };\n\n  static node_index new_node(const diff\u0026 d) {\n    node_index i = ni++;\n    n[i].s = 1;\n    n[i].h = 1;\n    n[i].d = d;\n    return i;\n  }\n  static void fix(node_index i) {\n    n[i].s = n[i][0].s + n[i][1].s;\n    n[i].h = std::max(n[i][0].h, n[i][1].h) + 1;\n    n[i].d = diff::ope(n[i][0].d, n[i][1].d);\n  }\n\n  static size_type child_dir(node_index i) {\n    if(n[i].p) {\n      if(n[n[i].p].c[0] == i) { return 0; }\n      else if(n[n[i].p].c[1] == i) { return 1; }\n      assert(false);\n    }\n    return -1;\n  }\n  static node_index rotate(node_index x, size_type dir) {\n    node_index p = n[x].p;\n    size_type x_dir = child_dir(x);\n    node_index y = n[x].c[1 ^ dir];\n    n[n[y][dir].p = x].c[1 ^ dir] = n[y].c[dir];\n    n[n[x].p = y].c[dir] = x;\n    n[y].p = p;\n    if(p \u003e 0) n[p].c[x_dir] = y;\n    fix(x);\n    fix(y);\n    return y;\n  }\n\n  static node_index balance(node_index i) {\n    fix(i);\n    if(n[i][0].h - n[i][1].h == 2) {\n      if(n[i][0][0].h - n[i][0][1].h == -1) {\n        rotate(n[i].c[0], 0);\n      }\n      return rotate(i, 1);\n    }\n    else if(n[i][0].h - n[i][1].h == -2) {\n      if(n[i][1][0].h - n[i][1][1].h == 1) {\n        rotate(n[i].c[1], 1);\n      }\n      return rotate(i, 0);\n    }\n    return i;\n  }\n\n\n  static node_index merge_dir(node_index l, node_index root, node_index r, size_type dir) {\n    while(std::abs(n[l].h - n[r].h) \u003e 1) {\n      l = n[l].c[dir];\n    }\n    node_index x = n[l].p;\n    n[n[l].p = root].c[dir ^ 1] = l;\n    n[n[r].p = root].c[dir] = r;\n    fix(root);\n    n[n[root].p = x].c[dir] = root;\n    x = root;\n    while(n[x].p \u003e 0) {\n      x = n[x].p;\n      x = balance(x);\n    }\n    return x;\n  }\n\n  static node_index merge(node_index l, node_index r) {\n    if(!l) return r;\n    else if(!r) return l;\n    else if(n[l].h \u003e= n[r].h) {\n      return merge_dir(l, new_node(diff()), r, 1);\n    }\n    else {\n      return merge_dir(r, new_node(diff()), l, 0);\n    }\n  }\n\n  static std::pair\u003cnode_index, node_index\u003e split(node_index root, size_type pos) {\n    if(pos == 0) return { 0, root };\n    if(pos == n[root].s) return { root, 0 };\n    node_index i = root;\n    node_index par = -1;\n    while(i \u003e 0 \u0026\u0026 pos != n[i][0].s) {\n      if(pos \u003c n[i][0].s) {\n        i = n[i].c[0];\n      }\n      else {\n        pos -= n[i][0].s;\n        i = n[i].c[1];\n      }\n    }\n    node_index l = n[i].c[0];\n    n[l].p = 0;\n    node_index r = n[i].c[1];\n    n[r].p = 0;\n    size_type dir;\n    node_index p = n[i].p;\n    node_index pd = child_dir(i);\n    while(dir = pd, i = p, i \u003e 0) {\n      //std::cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c dir \u003c\u003c std::endl;\n      pd = child_dir(i);\n      p = n[i].p;\n      n[i].p = 0;\n      if(dir == 0) {\n        n[i][1].p = 0;\n        //std::cout \u003c\u003c \"merge_dir, 0\" \u003c\u003c std::endl;\n        //debug(n[i].c[1], \"\");\n        //debug(r, \"\");\n        r = merge_dir(n[i].c[1], i, r, 0);\n        //debug(r, \"\");\n      }\n      else {\n        n[i][0].p = 0;\n        //std::cout \u003c\u003c \"merge_dir, 0\" \u003c\u003c std::endl;\n        //debug(n[i].c[0], \"\");\n        //debug(l, \"\");\n        l = merge_dir(n[i].c[0], i, l, 1);\n        //debug(l, \"\");\n      }\n    }\n    return { l, r };\n  }\n\n  static node_index at(node_index i, size_type pos) {\n    while(n[i].c[0]) {\n      if(pos \u003c n[i][0].s) {\n        i = n[i].c[0];\n      }\n      else {\n        pos -= n[i][0].s;\n        i = n[i].c[1];\n      }\n    }\n    return i;\n  }\n\n  static void set(node_index i, size_type pos, diff v) {\n    node_index par = -1;\n    while(n[i].c[0]) {\n      if(pos \u003c n[i][0].s) {\n        i = n[i].c[0];\n      }\n      else {\n        pos -= n[i][0].s;\n        i = n[i].c[1];\n      }\n    }\n    n[i].d = v;\n\n    while(i = n[i].p, i \u003e 0) {\n      fix(i);\n    }\n  }\n\n  static size_type index(node_index i) {\n    size_type pos = 0;\n    while(n[i].p \u003e 0) {\n      if(child_dir(i) == 1) {\n        pos += n[n[i].p][0].s;\n      }\n      i = n[i].p;\n    }\n    return pos;\n  }\n\n  static node_index search(node_index i, height_type pos) {\n    while(n[i].c[0]) {\n      if(n[i][0].d.d + n[i][1].d.min_d \u003c= pos \u0026\u0026 pos \u003c n[i][0].d.d + n[i][1].d.max_d) {\n        pos -= n[i][0].d.d;\n        i = n[i].c[1];\n      }\n      else {\n        i = n[i].c[0];\n      }\n    }\n    return i;\n  }\n\n  static std::pair\u003cnode_index, node_index\u003e min_depth_split(node_index i) {\n    node_index r = i;\n    size_type pos = n[i].d.min_d;\n    size_type res = 0;\n    while(n[i].c[0]) {\n      if(n[i][0].d.d + n[i][1].d.min_d \u003c= pos \u0026\u0026 pos \u003c n[i][0].d.d + n[i][1].d.max_d) {\n        pos -= n[i][0].d.d;\n        res += n[i][0].s;\n        i = n[i].c[1];\n      }\n      else {\n        i = n[i].c[0];\n      }\n    }\n    return split(r, res);\n  }\n\n  static void debug(node_index i, std::string s) {\n    if(i == 0) {\n      std::cout \u003c\u003c s \u003c\u003c 0 \u003c\u003c std::endl;\n      return;\n    }\n    std::cout \u003c\u003c s \u003c\u003c i \u003c\u003c \" = \" \u003c\u003c n[i].d.p_value \u003c\u003c \" = \" \u003c\u003c n[i].p \u003c\u003c \" = \" \u003c\u003c n[i].s \u003c\u003c std::endl;\n    if(n[i].c[0] \u0026\u0026 n[i][0].p != i) {\n      assert(false);\n    }\n    debug(n[i].c[0], s + \"  \");\n    if(n[i].c[1] \u0026\u0026 n[i][1].p != i) {\n      assert(false);\n    }\n    debug(n[i].c[1], s + \"  \");\n  }\n\n\npublic:\n\n  node_index root;\n  retroactive_stack(): root(0) {}\n  retroactive_stack(node_index i): root(i) {}\n\n  static node_index new_push_operation(value_type val) {\n    return new_node(diff::push_diff(val));\n  }\n  static node_index new_pop_operation() {\n    return new_node(diff::pop_diff());\n  }\n\n  retroactive_stack\u0026 merge(retroactive_stack right) {\n    root = merge(this-\u003eroot, right.root);\n    return *this;\n  }\n  retroactive_stack split(node_index i) {\n    auto p = split(root, index(i));\n    retroactive_stack avl;\n    avl.root = p.second;\n    root = p.first;\n    return avl;\n  }\n\n  void update(node_index i, diff v) {\n    set(root, index(i), v);\n  }\n\n  size_type operation_size() {\n    return n[root].s;\n  }\n\n  height_type stack_size() {\n    return n[root].d.d;\n  }\n\n  value_type top() {\n    auto P = min_depth_split(root);\n    auto res = n[search(P.second, n[P.second].d.d - 1)].d.p_value;\n    root = merge(P.first, P.second);\n    return res;\n  }\n\n  void debug() {\n    debug(root, \"\");\n  }\n};\n\nretroactive_stack::size_type retroactive_stack::ni = 1;\nretroactive_stack::node retroactive_stack::n[2020202];\n\nint main() {\n  std::vector\u003cint\u003e opes;\n  opes.push_back(retroactive_stack::new_push_operation(1));\n  opes.push_back(retroactive_stack::new_push_operation(2));\n  opes.push_back(retroactive_stack::new_push_operation(3));\n\n  retroactive_stack st;\n\n  st.merge(retroactive_stack::new_pop_operation());\n  st.merge(retroactive_stack::new_pop_operation());\n  st.merge(retroactive_stack::new_pop_operation());\n\n  for(auto i: opes) {\n    st.merge(retroactive_stack(i));\n  }\n  std::cout \u003c\u003c st.top() \u003c\u003c std::endl; // 3\n\n  int pop_ope = retroactive_stack::new_pop_operation();\n\n  st.merge(retroactive_stack(pop_ope));\n\n  std::cout \u003c\u003c st.top() \u003c\u003c std::endl; // 2\n\n  st.merge(retroactive_stack(retroactive_stack::new_pop_operation()));\n  std::cout \u003c\u003c st.top() \u003c\u003c std::endl; // 1\n\n  st.update(pop_ope, retroactive_stack::diff::push_diff(4));\n  std::cout \u003c\u003c st.top() \u003c\u003c std::endl; // 3 (push 1 -\u003e push 2 -\u003e push 3 -\u003e push 4 -\u003e pop)\n\n  auto after = st.split(opes[2]);\n  std::cout \u003c\u003c st.top() \u003c\u003c std::endl; // 2 st := (push 1 -\u003e push 2)\n}\n\n```\n\nstar押してね(承認欲求)\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/genetic_local_search_IHC":{"title":"Genetic Local Search + MSXFの勉強とIntroduction to Heuristic Contest","content":"\n# 概要\n\n遺伝的アルゴリズム(Genetic Algorithm)の練習として[Introduction to Heuristic Contestの問題](https://atcoder.jp/contests/intro-heuristics/tasks/intro_heuristics_a)を解いてみました。最終的なスコアは117Mで焼きなましの124Mには劣りますが、良い成績は得られていそうです。\n\n[前回勉強したGenetic Algorithmの入門の話]({{\u003c ref \"/notes/genetic_local_search_tsp\" \u003e}})も参考に\n\n# 方針\n\n[遺伝的局所探索法によるジョブショップスケジューリング問題の解法](https://cir.nii.ac.jp/crid/1050001337886598400)で述べられている\n\n- Genetic Local Search(遺伝的局所探索, GLS)\n- Multi Step Crossover Fusion(多段階探索交叉, MSXF)\n\nの2つの手法を取り入れました。\n\n# Genetic Local Search\n\n各世代を作り終わった後に、局所探索を行うことで個体を改善することを試みます。[前回]({{\u003c ref \"/notes/genetic_local_search_tsp\" \u003e}})\n\n# Multi Step Crossover Fusion\n\n交叉するときによりよい交叉を探索によって求め子孫を作る、というのがMSXFの基本的なお気持ちです。親二つを交叉してできる子孫の空間を探索する際、親xからの距離によって子孫が「どれくらい親xっぽいか」を定義し、探索を進めるにつれて「どれくらい親xに似せるか」を絞っていきます。空間を探索している際、その遷移を受理するかしないかは、焼きなましと同じ方法で行います。\n\n# 解法の交叉の方法\n\n交叉は1点交叉を用いました(2交叉も試しましたが、微妙に1点交叉の方が強かったです)。論文のMSXFをそのまま採用すると実行時間が足りないので、次のようにアレンジしました。\n\n1. 親$x$の前半分、親$y$の後ろ半分を1点交叉したものを初期解$c$とする。$n = D / 2$とする。\n2. $m = n + \\mathrm{rand}(-15, 15)$として、$m$で交叉したものを$p$とする。\n3. 確率$\\exp((\\mathrm{score}(p) - \\mathrm{score}(c)) / T)$で受理、$c = p, n = m$と更新する。\n4. 1-3を指定回数繰り返す\n\nこれを採用すると113Mから117Mまで伸びます。\n\n[提出](https://atcoder.jp/contests/intro-heuristics/submissions/37220631)\n\n{{\u003c details 提出コード \u003e}}\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n#include \u003ccmath\u003e\n#include \u003calgorithm\u003e\n#include \u003ccstdint\u003e\n#include \u003crandom\u003e\n#include \u003ciomanip\u003e\n#include \u003cbits/stdc++.h\u003e\n\nstruct Timer {\n  std::chrono::high_resolution_clock::time_point st;\n  Timer() { st = now(); }\n  std::chrono::high_resolution_clock::time_point now() { return std::chrono::high_resolution_clock::now(); }\n  std::chrono::milliseconds::rep span() {\n    auto ed = now();\n    return std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(ed - st).count();\n  }\n};\n\nusing u32 = std::uint_fast32_t;\nusing i64 = std::int_fast64_t;\nconstexpr int K = 26;\nint D;\nstd::vector\u003ci64\u003e C;\nstd::vector\u003cstd::vector\u003ci64\u003e\u003e S;\n\nusing Score = i64;\n\nstruct Individual {\n  std::vector\u003cint\u003e vec;\n\n  Individual() = default;\n  explicit Individual(std::vector\u003cint\u003e vec): vec(std::move(vec)) {}\n\n  Individual crossover(std::mt19937\u0026 mt, const Individual\u0026 y) const {\n    Individual mx;\n    Score score = -1e9;\n    int now = vec.size() / 2;\n    {\n      std::vector\u003cint\u003e next(vec.size());\n      std::copy(vec.begin(), vec.begin() + vec.size() / 2, next.begin());\n      std::copy(y.vec.begin() + vec.size() / 2, y.vec.end(), next.begin() + vec.size() / 2);\n      Individual child(std::move(next));\n      score = child.evaluate_state();\n      mx = std::move(child);\n    }\n\n    constexpr int Count = 30;\n    for(int q = 0; q \u003c Count; q++) {\n      int DIFF = 15;\n      int at = std::min(D - 1, std::max(1, std::uniform_int_distribution\u003c\u003e(-DIFF, DIFF - 1)(mt) + now));\n      if(at \u003e= 0) at++;\n      std::vector\u003cint\u003e next(vec.size());\n      std::copy(vec.begin(), vec.begin() + at, next.begin());\n      std::copy(y.vec.begin() + at, y.vec.end(), next.begin() + at);\n      Individual child(std::move(next));\n      Score next_score = child.evaluate_state();\n      if(score \u003c= next_score || std::bernoulli_distribution(std::exp(-(score - next_score) / 4e2))(mt)) {\n        score = next_score;\n        mx = std::move(child);\n        now = at;\n      }\n    }\n    return mx;\n  }\n\n  void mutation(std::mt19937\u0026 mt) {\n    std::bernoulli_distribution swap_dist(0.005);\n    for(int i = 1; i \u003c vec.size(); i++) {\n      if(swap_dist(mt)) {\n        std::uniform_int_distribution\u003c\u003e at_dist(std::max(0, i - 15), i - 1);\n        int j = at_dist(mt);\n        std::swap(vec[i], vec[j]);\n      }\n    }\n    for(int i = 0; i \u003c vec.size(); i++) {\n      if(swap_dist(mt)) {\n        vec[i] = std::uniform_int_distribution\u003c\u003e(0, K - 1)(mt);\n      }\n    }\n  }\n\n  Score evaluate_state() const {\n    i64 sum = 0;\n    std::vector\u003ci64\u003e before(K, -1);\n    for(int i = 0; i \u003c D; i++) {\n      int v = vec[i];\n      sum += S[i][v];\n      i64 d = i - before[v];\n      sum -= C[v] * d * (d - 1) / 2;\n      before[v] = i;\n    }\n    for(int v = 0; v \u003c K; v++) {\n      i64 d = D - before[v];\n      sum -= C[v] * d * (d - 1) / 2;\n    }\n    return sum;\n  }\n};\n\n\n\nvoid local_search(std::mt19937\u0026 mt, Individual\u0026 x, Score\u0026 score) {\n  constexpr int Count = 50;\n  constexpr double T = 5e2;\n  for(int q = 0; q \u003c Count; q++) {\n    if(std::bernoulli_distribution(0.5)(mt)) {\n      int i = std::uniform_int_distribution\u003c\u003e(0, x.vec.size() - 1)(mt);\n      int j = std::uniform_int_distribution\u003c\u003e(std::max(0, i - 13), std::min(D - 2, i + 12))(mt);\n      if(j \u003e= i) j++;\n      std::swap(x.vec[i], x.vec[j]);\n      Score next = x.evaluate_state();\n      if(score \u003c= next || std::bernoulli_distribution(std::exp(-(score - next) / T))(mt)) {\n        score = next;\n      }\n      else {\n        std::swap(x.vec[i], x.vec[j]);\n      }\n    }\n    else {\n      int i = std::uniform_int_distribution\u003c\u003e(0, x.vec.size() - 1)(mt);\n      int before = x.vec[i];\n      x.vec[i] = std::uniform_int_distribution\u003c\u003e(0, K - 2)(mt);\n      if(before \u003c= x.vec[i]) x.vec[i]++;\n      Score next = x.evaluate_state();\n      if(score \u003c= next || std::bernoulli_distribution(std::exp(-(score - next) / T))(mt)) {\n        score = next;\n      }\n      else {\n        x.vec[i] = before;\n      }\n    }\n  }\n}\n\nstruct Generation {\n  constexpr static int Count = 12;\n  constexpr static int Elite = 4;\n  constexpr static int NewInd = 3;\n  std::vector\u003cstd::pair\u003cIndividual, Score\u003e\u003e inds;\n\n  void init(std::mt19937\u0026 mt) {\n    for(int i = 0; i \u003c Count; i++) {\n      std::vector\u003cint\u003e init(D);\n      for(int d = 0; d \u003c D; d++) {\n        init[d] = std::uniform_int_distribution\u003c\u003e(0, K - 1)(mt);\n      }\n      Individual x(std::move(init));\n      Score score = x.evaluate_state();\n      inds.emplace_back(std::move(x), std::move(score));\n    }\n  }\n\n  Generation next_gen(std::mt19937\u0026 mt) const {\n    Generation next;\n\n    std::vector\u003cint\u003e idx(Count);\n    std::iota(idx.begin(), idx.end(), 0);\n\n    // elitism\n    std::nth_element(idx.begin(), idx.begin() + Elite - 1, idx.end(), [\u0026](int i, int j) { return inds[i].second \u003e inds[j].second; });\n    for(int i = 0; i \u003c Elite; i++) {\n      next.inds.push_back(inds[idx[i]]);\n    }\n\n    // selection \u0026 crossover by roulette\n    Score max_score = std::max_element(inds.begin(), inds.end(), [](auto\u0026 a, auto\u0026 b) { return a.second \u003e b.second; })-\u003esecond;\n    std::vector\u003cdouble\u003e pie(inds.size());\n    for(int i = 0; i \u003c inds.size(); i++) {\n      pie[i] = inds[i].second - max_score;\n      if(i \u003e 0) {\n        pie[i] += pie[i - 1];\n      }\n    }\n    std::uniform_real_distribution\u003c\u003e dice(0, pie.back());\n    for(int i = Elite; i \u003c Count - NewInd; i++) {\n      int x = std::lower_bound(pie.begin(), pie.end(), dice(mt), [](auto\u0026 a, double v) { return a \u003c v; }) - pie.begin();\n      double diff = pie[x] - (x == 0 ? 0 : pie[x - 1]);\n      int y = std::lower_bound(pie.begin(), pie.end(), std::uniform_real_distribution\u003c\u003e(0, pie.back() - diff)(mt),\n          [\u0026](auto\u0026 a, double v) { return (a \u003e= pie[x] ? a - diff : a ) \u003c v; }\n        ) - pie.begin();\n      Individual child = inds[x].first.crossover(mt, inds[y].first);\n      child.mutation(mt);\n      Score score = child.evaluate_state();\n      next.inds.emplace_back(std::move(child), std::move(score));\n    }\n    for(int i = Count - NewInd; i \u003c Count; i++) {\n      std::vector\u003cint\u003e init(D);\n      for(int d = 0; d \u003c D; d++) {\n        init[d] = std::uniform_int_distribution\u003c\u003e(0, K - 1)(mt);\n      }\n      Individual x(std::move(init));\n      /*\n      Individual x(next.inds[i - Count + NewInd].first);\n      x.mutation(mt);\n      x.mutation(mt);\n      */\n      Score score = x.evaluate_state();\n      next.inds.emplace_back(std::move(x), std::move(score));\n    }\n    for(auto\u0026 [x, score]: next.inds) {\n      local_search(mt, x, score);\n    }\n    return next;\n  }\n};\n\nint main() {\n  std::mt19937 mt;\n  //const int Century = 100000;\n  std::cin \u003e\u003e D;\n  C.resize(K);\n  for(int i = 0; i \u003c K; i++) {\n    std::cin \u003e\u003e C[i];\n  }\n  S.resize(D, std::vector\u003ci64\u003e(K));\n  for(int i = 0; i \u003c D; i++) {\n    for(int j = 0; j \u003c K; j++) {\n      std::cin \u003e\u003e S[i][j];\n    }\n  }\n  Generation gen;\n  gen.init(mt);\n\n  Timer timer;\n\n  //for(int q = 0; q \u003c Century; q++) {\n  int q = 0;\n  Individual MAX;\n  Score score = -1e9;\n  while(timer.span() \u003c 1980) {\n    gen = gen.next_gen(mt);\n    q++;\n    if(q % 100 == 0) {\n      auto\u0026 NEXT = *std::max_element(gen.inds.begin(), gen.inds.end(), [](const auto\u0026 a, const auto\u0026 b) { return a.second \u003c b.second; });\n      if(score \u003c NEXT.second) {\n        MAX = NEXT.first;\n        score = NEXT.second;\n      }\n      std::cerr \u003c\u003c q \u003c\u003c \" \" \u003c\u003c score \u003c\u003c std::endl;\n    }\n    //std::cerr \u003c\u003c std::fixed \u003c\u003c std::setprecision(10) \u003c\u003c q++ \u003c\u003c \"\\t\" \u003c\u003c MAX.second \u003c\u003c std::endl;\n  }\n  std::cerr \u003c\u003c timer.span() \u003c\u003c std::endl;\n  std::cerr \u003c\u003c score \u003c\u003c std::endl;\n  for(int i = 0; i \u003c D; i++) {\n    std::cout \u003c\u003c MAX.vec[i] + 1 \u003c\u003c \"\\n\";\n  }\n}\n```\n\n{{\u003c/details\u003e}}\n\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/genetic_local_search_tsp":{"title":"Genetic Algorithmの勉強と巡回セールスマン問題","content":"\n# Genetic Algorithm\n\nGenetic Algorithm(GA, 遺伝的アルゴリズム)は、問題に対する解を個体とし、選択・交叉・突然変異の操作によって個体の集合からなる世代を更新し、最適解を導くヒューリスティックアルゴリズムです。\n\nAtCoderの巡回セールスマン問題のジャッジを通せたので、手法を書き残しておきます。[ジャッジ結果](https://atcoder.jp/contests/typical-algorithm/submissions/37113247)\n\n# 染色体の定義\n\n各個体には「染色体」と呼ばれる、解を持つ情報の列を持たせます。今回は訪れる頂点番号の順番をそのまま順列として保持しました。\n\n# 交叉\n\nGenetic Algorithm中では、二つの染色体を混ぜて新しい染色体を作り出す「交叉」という操作を行います。この操作では二つの解の特徴を残しながら繋ぐ必要があります。今回は順序交叉を用いました。\n\n順序交叉は片方の親から一部の順列をそのまま引き継ぎ、残りの部分についてはもう一つの親での相対的な順序で補完するというものです。\n\n```\np1 = (1 2 3 | 4 5 6 7 | 8 9)\np2 = (4 5 2 | 1 8 7 6 | 9 3)\n\np2'= (9 3 2 1 8)\n\nch = (2 1 8 | 4 5 6 7 | 9 3)\n```\n\n# 突然変異\n\n解が確率で新しい解を見つけるように、突然変異という操作を行います。今回は、確率で2点swapを行うことにしました。\n\n# 選択\n\nAlgorithmの中で、どの個体を交叉させるかを選ぶ必要があり、これを「選択」と呼びます。今回は、個体が持つ解の距離から重みを計算し、その重みによって個体を2つ選んで交叉を行いました。\n\n# Elitism\n\n優秀な個体は次世代にそのままコピーして引き継ぐ手法があり、これをElitismといいます。今回はこれも採用しました。\n\nここまでの手法で、2WAまで減らすことができますが、これを無くすためにはGenetic Algorithm自体を改善する必要があります。\n\n# Genetic Local Search\n\n各世代で選択を行う前に、全ての個体について局所探索を行い、解をあらかじめある程度よくしておくという手法「Genetic Local Search(遺伝的局所探索)」が存在し、巡回セールスマンに有効であるという研究があります。これを採用することでACすることができました。\n\n## 参考記事\n\n- [順序問題へのGAの適用](http://ono-t.d.dooo.jp/GA/GA-order.html)\n- [Genetic algorithm full scratch with R - slideshare](https://www.slideshare.net/kato_kohaku/genetic-algorithm-full-scratch-with-r)\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/impl_abstract_dijkstra":{"title":"グラフ, 格子状のグラフ, 次元拡張グラフを同じコードで扱う抽象化BFS, DijkstraのC++14実装","content":"\nこれすごく悩んでいたんですけど, 新しい実装法を考えたらスッキリしたのでまとめます.\n\n先駆者がいたらごめん, 勝手に**にう式グラフ抽象化**って言っちゃおうかな\n\n## 意思\n\nDijkstraやBFSのライブラリを書いておきたい！\n\n## 問題点\n\n- 同じアルゴリズムのライブラリを, 種類の違うグラフに対して一つずつ書くのは本当にイヤ\n- 格子状のグラフをわざわざ, `std::vector\u003cstd::vector\u003cint\u003e\u003e G`に構築するのは定数倍があるのでイヤ.\n- 問題を解くために次元拡張したグラフをわざわざ構築するのは, キレイじゃない\n- `struct edge`がC++においてはなんかイヤ, 隣接する頂点が`int to`で固定しないとダメだったりでイヤ(Rustのtraitとかあるならまだしも 個人差あり)\n- そもそも`struct edge`を毎回書くのもイヤ(競プロなので)\n- 隣接リストを毎回`std::vector\u003cedge\u003e`で返すのもキレイじゃない, できるだけ無駄はなくしたい.\n\nどうしよう(欲求が多すぎる)\n\n## 解決\n\n抽象化しにくいのはなぜかというと, `struct edge`と隣接行列の保持の仕方がグラフの種類ごとに違うからです.  なので, 方針としては\n\n- `struct edge`は, ライブラリに触れさせない\n- 隣接行列は, 直接ライブラリに触れさせない\n\nという点を実現できれば良いです. ですが, 隣接行列を`std::vector\u003cなんたら\u003e`で返す関数を返すのも美しくありません. なので, これを関数で受けることにします.\n\n具体的には, \n\n1. BFS関数は, `delta`という隣接行列を生成する関数を受け取ります.\n2. 隣接する頂点を列挙する時は, `delta`に, 現在の頂点$v$と, **$v$と隣接する頂点を引数にとる, 探索をする関数**を渡します.\n3. `delta`が隣接する頂点を, 引数で渡された関数の引数に入れて探索をしてもらいます.\n4. できる!\n\nDijkstraの場合には, `delta`に渡す関数を`(V t /* 隣接頂点 */, W cost /* 辺のコスト */)`にしておけばOKですね.\n\n頂点の抽象化は, `index(V) -\u003e int`があればいいです.\n\n## コード\n\n### BFS\n\n```cpp\n#include \u003cvector\u003e\n#include \u003cqueue\u003e\nusing i64 = long long;\n\n/*\n * delta(V v, fn (V t))\n * index(V v) -\u003e int\n */\ntemplate\u003cclass V, class Delta, class Index\u003e\nstd::vector\u003ci64\u003e bfs(std::size_t N, V s, Delta delta, Index index) {\n  std::vector\u003ci64\u003e dist(N, -1);\n  std::queue\u003cV\u003e que;\n  dist[index(s)] = 0;\n  que.push(s);\n  while(!que.empty()) {\n    V v = que.front();\n    que.pop();\n    delta(v, [\u0026](V t) {\n        if(dist[index(t)] == -1) {\n          dist[index(t)] = dist[index(v)] + 1;\n          que.push(t);\n        }\n    });\n  }\n  return dist;\n}\n```\n\n### Dijkstra\n\n```cpp\n#include \u003cvector\u003e\n#include \u003cqueue\u003e\n\n/*\n * delta(V v, fn (V t, W weight))\n * index(V v) -\u003e int\n */\ntemplate\u003cclass V, class W, class Delta, class Index\u003e\nstd::vector\u003cW\u003e dijkstra(std::size_t N, W inf, V s, Delta delta, Index index) {\n  std::vector\u003cW\u003e dist(N, inf);\n  using P = std::pair\u003cW, V\u003e;\n  std::priority_queue\u003cP, std::vector\u003cP\u003e, std::greater\u003cP\u003e\u003e que;\n  que.push({ dist[index(s)] = W(), s });\n  while(!que.empty()) {\n    W d = que.top().first;\n    V v = que.top().second;\n    que.pop();\n    if(dist[index(v)] \u003c d) continue;\n    delta(v, [\u0026](V t, W weight) {\n        if(dist[index(t)] \u003e dist[index(v)] + weight) {\n          que.push({ dist[index(t)] = dist[index(v)] + weight, t });\n        }\n    });\n  }\n  return dist;\n}\n```\n\n### How To Use\n\n格子グラフに関しては, こんな感じに予めライブラリを書いておくと楽です.\n\n```cpp\ntemplate\u003cclass F\u003e\nstruct lattice_delta {\n  i64 H, W;\n  F f;\n  using P = std::pair\u003ci64, i64\u003e;\n  lattice_delta(i64 H, i64 W, F f): H(H), W(W), f(f) {}\n  template\u003cclass Func\u003e\n  void operator()(P v, Func func) {\n    const static vector\u003ci64\u003e dx { 1, 0, -1, 0 };\n    i64 i = v.first;\n    i64 j = v.second;\n    for(i64 q = 0; q \u003c 2; q++) {\n      i64 x = i + dx[q];\n      i64 y = j + dx[q ^ 1];\n      if(0 \u003c= x \u0026\u0026 x \u003c H \u0026\u0026 0 \u003c= y \u0026\u0026 y \u003c W) {\n        f(P(i, j), P(x, y), func);\n      }\n    }\n  }\n};\n \ntemplate\u003cclass F\u003e\nlattice_delta\u003cF\u003e make_lattice_delta(i64 H, i64 W, F f) { return lattice_delta\u003cF\u003e(H, W, f); }\n \nstruct lattice_index {\n  i64 H, W;\n  using P = std::pair\u003ci64, i64\u003e;\n  lattice_index(i64 H, i64 W): H(H), W(W) {}\n  i64 operator()(P v) {\n    return v.first * W + v.second;\n  }\n};\n```\n\nこれで, [Maze Master](https://atcoder.jp/contests/abc151/tasks/abc151_d)は以下のように解くことができます.\n\n```cpp\nint main() {\n  i64 H, W;\n  cin \u003e\u003e H \u003e\u003e W;\n  vector\u003cstring\u003e S(H);\n  rep(i,0,H) {\n    cin \u003e\u003e S[i];\n  }\n  i64 ans = 0;\n\n  using P = std::pair\u003ci64, i64\u003e;\n  auto delta = make_lattice_delta(H, W, [\u0026](P v, P t, auto func) {\n    if(S[t.first][t.second] == '.') func(t);\n    }\n  );\n  auto index = lattice_index(H, W);\n\n  rep(i,0,H) rep(j,0,W) {\n    if(S[i][j] == '#') continue;\n    auto res = bfs(H * W, P(i, j), delta, index);\n    ans = std::max(ans, *std::max_element(all(res)));\n  }\n  cout \u003c\u003c ans \u003c\u003c endl;\n}\n```\n\nまた, 次元拡張グラフを扱う[E - Two Currencies](https://atcoder.jp/contests/abc164/tasks/abc164_e)は, こんな感じで.\n\n```cpp\nint main() {\n  i64 N, M, S;\n  cin \u003e\u003e N \u003e\u003e M \u003e\u003e S;\n  S = std::min(S, 2500ll);\n \n  struct edge {\n    i64 to;\n    i64 a;\n    i64 b;\n  };\n \n  vector\u003cvector\u003cedge\u003e\u003e G(N);\n  rep(i,0,M) {\n    i64 u, v, a, b;\n    cin \u003e\u003e u \u003e\u003e v \u003e\u003e a \u003e\u003e b;\n    u--;\n    v--;\n    G[u].push_back({ v, a, b });\n    G[v].push_back({ u, a, b });\n  }\n \n  vector\u003ci64\u003e C(N);\n  vector\u003ci64\u003e D(N);\n  rep(i,0,N) {\n    cin \u003e\u003e C[i] \u003e\u003e D[i];\n  }\n \n  using P = std::pair\u003ci64, i64\u003e;\n  auto index = [\u0026](P p) { return p.first * 2501 + p.second; };\n  auto delta = [\u0026](P vv, auto func) {\n    i64 v = vv.first;\n    i64 c = vv.second;\n    func(P(v, std::min(c + C[v], 2500ll)), D[v]);\n    for(auto e: G[v]) {\n      if(e.a \u003c= c) {\n        func(P(e.to, c - e.a), e.b);\n      }\n    }\n  };\n  auto res = dijkstra(N * 2501, (i64)(1e17), P(0, S), delta, index);\n  rep(i,1,N) {\n    i64 ans = res[index(P(i, 0))];\n    rep(j,0,2501) {\n      ans = std::min(ans, res[index(P(i, j))]);\n    }\n    cout \u003c\u003c ans \u003c\u003c \"\\n\";\n  }\n}\n```\n\nC++14ならジェネリックラムダあるので, `auto func`って書き殴れるのでいいですね.\n\n## 提出ページ\n\n- 格子グラフのBFS: [D - Maze Master - 提出 #11773027 - AtCoder Beginner Contest 151](https://atcoder.jp/contests/abc151/submissions/11773027) ちょっとコード違うけど許して\n- 格子グラフの01dial(01-bfs): [A - Range Flip Find Route - 提出 #11773947 - AtCoder Grand Contest 043](https://atcoder.jp/contests/agc043/submissions/11773947)\n- 次元拡張グラフのDijkstra: [E - Two Currencies - 提出 #12401080 - AtCoder Beginner Contest 164](https://atcoder.jp/contests/abc164/submissions/12401080)\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/kupc2019-k":{"title":"KUPC2019 K - One or AllをFPSで","content":"\n[KUPC2019 K - One or All](https://atcoder.jp/contests/kupc2019/tasks/kupc2019_k)\n\n$$\n\\begin{align}\n\u0026(x + y + z + x^{-1} + y^{-1} + z^{-1} + xyz + (xyz)^{-1})^n \\\\\\\\\n\u0026 = \\frac{(1 + xy)^n (1 + xz)^n (1 + yz)^n}{x^n y^n z^n} \\\\\\\\\n\u0026 = (xyz)^{-n} \\sum_{i, j, k} \\binom{n}{i} \\binom{n}{j} \\binom{n}{k} (xy)^i (xz)^j (yz)^k \\\\\\\\\n\u0026 = (xyz)^{-n} \\sum_{i, j, k} \\binom{n}{i} \\binom{n}{j} \\binom{n}{k} x^{i+j} y^{i+k} z^{j+k} \\\\\\\\\n\\end{align}\n$$\n\n次数が$\\mod p$されるので、まず$(1 + xy)^n = \\sum_{i} \\binom{n}{i} (xy)^i$を$\\mod p$で集約します。\n\n$i+j \\equiv p-n, i+k \\equiv q-n, j+k \\equiv r-n \\\\ \\pmod p$となる$i, j, k$を求めれば、$x^p y^q z^r$の係数を求められます。\n\n[提出コード](https://atcoder.jp/contests/kupc2019/submissions/30922085)\n\n```cpp\nvector\u003cfp\u003e acc(M);\nrep(i,0,N + 1) acc[i % M] += fact.binom(N, i);\n\nfp sum = 0;\nrep(i,0,M) {\n  i64 j = (p - i + M + N) % M;\n  i64 k = (q - i + M + N) % M;\n  if((j + k - N % M + M) % M == r) {\n    sum += acc[i] * acc[j] * acc[k];\n  }\n}\ncout \u003c\u003c sum \u003c\u003c endl;\n```\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/lc_associative_array":{"title":"Library Checker - Associative Array に関するいろいろ","content":"\n[Library Checker - Associative Array]を解くに当たってのいろいろをまとめておきます.\n\n## 概要\n\nAssociative Arrayは, Mapとよく呼ばれるデータ構造です. キーとそれに対応する値の組を保持し, キーで検索して値を参照することができます.\n\nAssociative Arrayを実現するデータ構造は,\n\n- Map型の平衡二分探索木(ただし, キーが比較可能であることが条件)\n  - `std::map`\n  - 自作\n- HashMap\n  - `std::unordered_map`\n  - 自作(メインテーマ)\n\n\n## `std::map`: 523ms\n\n[Submit Info #12076](https://judge.yosupo.jp/submission/12076)\n\nこれを基準にしていきます\n\n## `merge/split型 AVL Tree`: 682ms\n\n[Submit Info #12082](https://judge.yosupo.jp/submission/12082)\n\n`insert/erase`の非再帰AVL Treeを持ってません, すみません...  \n`merge/split`の非再帰AVL Treeを無理やりMapにしたものです. 余分なデータとか, 探索をしているのでもっと早くなると思います.\n\n## `std::unordered_map`: TLE(?????)\n\n[Submit Info #12083](https://judge.yosupo.jp/submission/12083)\n\n`std::unordered_map`だとTLEします. `unordered_map_killer_01`にやられていますね.  \nこれは, [std::unordered_mapのhash衝突による速度低下をさせてみる - うさぎ小屋](https://kimiyuki.net/blog/2017/03/08/unordered-map-hash-collision/)で紹介されているように, `std::unordered_map`をそのまま使うとハッシュ衝突をより起こすケースでTLEになってしまいます. 対策としては,\n\n- `std::map`を使う\n- `hash`関数をランダムに変える\n\nです. hash関数については, 下に書きます.\n\n## 自作HashMap: 114ms\n\n[Submit Info #9787](https://judge.yosupo.jp/submission/9787)\n\n自作する際には, この[高速なハッシュテーブルを設計する | POSTD](https://postd.cc/designing-a-fast-hash-table/)という記事を参考にしました. とてもわかりやすいので, 自作する, しないにしろ読んでおいて損はないです.\n\n- オープンアドレス法: 衝突したら, テーブルの空いている別の場所を探す\n- 2冪の制約: mod操作が早いので\n- 線形探索法: 衝突したらインデックスをインクリメントしていって探索する\n- ハッシュをメモしない\n\nという方針で実装しました. \n\nハッシュ関数については, [Gist - badboy/inthash.md Integer Hash Function](https://gist.github.com/badboy/6267743)を参考にしました. ハッシュ関数の実装と解説が載っています. 解説は読み切れていません...\n\n## `std::unordered_map with Hashu64`: 352ms\n\n[Submit Info #12087](https://judge.yosupo.jp/submission/12087)\n\nハッシュ関数を変えると`std::unordered_map`でもACできましたが, 自作のほうがめっちゃ早いですね\n\n## しめ\n\n自作HashMapを持っておくと, 他のデータ構造に後少し速さを求めたいときに使うことができたりするので便利です.  \n`std::map`でACカウントだけしている人はぜひこの機会に書いてみてはいかがでしょうか.\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/lexicase_booleanCSP":{"title":"Genetic Algorithm + Lexicase SelectionによるBoolean CSPのアプローチ","content":"\n# 概要\n\n多目的関数の場合に線形和を取るとパラメータ調整に時間がかかってしまう。特に、目的関数がとても多い場合はもっと難しくなる。ここでは、多目的関数Genetic AlgorithmのSelection(選択)で使えるLexicase Selectionの概要と、それを用いたBoolean CSPへのアプローチをメモしておく。\n\n今回も、目的関数は小さくするのを目標とする。\n\n参考: [Lexicase Selection Beyond Genetic Programming](https://faculty.hampshire.edu/lspector/pubs/lexicase-beyond-gp-preprint.pdf), [スライド版](https://pdfs.semanticscholar.org/1a81/80f85842e81f1a8a85120d38ed90ca52e70b.pdf)\n\n# Lexicase Selection\n\nLexicase Selectionは以下のようなアルゴリズムである。\n\n1. $I$を現在の世代の個体全ての集合とする。\n2. 目的関数をランダムにシャッフルした配列$f_i$を構成する\n3. $i = 1..$について\n  1. $I$を「$I$の中で$f_i$を最小にする個体の集合」に更新する。\n4. $I$の中からランダムに一つ取り出し、それを親に選択する。\n\n# Boolean CSP\n\nCSP(制約充足問題)で変数の取る値が01になったものである。下のような式を真にするような変数の割り当てを見つける問題である。\n\n$(\\neg x_1 \\lor x_3 \\lor x_0) \\land (x_2 \\lor x_0 \\lor x_4) \\land (x_0 \\lor x4 \\lor \\neg x_1)$\n\n# multi-objective Genetic Algorithmへの落とし込み\n\n変数はbit列で表すことができる。交叉は1点交叉や一様交叉を用いることができる。\n\nこの問題をmulti-objectiveに落とし込む方法だが、$\\land$で区切られた節(Clausesと言うらしい)それぞれについて、真なら0、そうでなければ1という目的関数を作ることで構成できる。ただし、全てを分けるととてもパラメータが多くなってしまうので、いくつかの節を固めて目的関数にすることができる。この時、節の真の個数を目的関数にすることができる。\n\n# 実装\n\n`N`は変数の個数、`C`は制約の数、`Clauses`は目的関数で節をまとめる数、`V`はV-SATを表す。\n\n\n{{\u003c details 提出コード \u003e}}\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n#include \u003ccstdint\u003e\n#include \u003crandom\u003e\n#include \u003calgorithm\u003e\n\nusing bits = std::uint64_t;\n\nconstexpr int N = 60;\nconstexpr int C = 50000;\nconstexpr int Clauses = 50;\nconstexpr int V = 3;\n\nstruct Individual {\n  bits x = 0;\n\n  Individual crossover(const Individual\u0026 p, std::mt19937\u0026 mt) const {\n    static std::uniform_int_distribution\u003c\u003e idx_dist(1, N - 1);\n    int i = idx_dist(mt);\n    bits next = (x \u0026 ((bits(1) \u003c\u003c i) - 1)) | (p.x \u0026 ~((bits(1) \u003c\u003c i) - 1));\n    return Individual { next };\n\n    /*\n\n    static std::uniform_int_distribution\u003cbits\u003e mask_dist(0, (bits(1) \u003c\u003c N) - 1);\n    bits mask = mask_dist(mt);\n    bits next = (x \u0026 mask) | (x \u0026 ~mask);\n    return Individual { next };\n    */\n  }\n\n  void mutation(std::mt19937\u0026 mt) {\n    constexpr double prob = 0.1;\n    static std::bernoulli_distribution mut(prob);\n    for(int i = 0; i \u003c N; i++) {\n      if(mut(mt)) {\n        x ^= (bits(1) \u003c\u003c i);\n      }\n    }\n  }\n};\n\nstruct Score {\n  std::vector\u003cint\u003e val;\n  int sum = 0;\n};\n\nstruct Constrains {\n  bits mask = 0;\n  bits rev_mask = 0;\n\n  void add(int i, int not_flag) {\n    mask |= (bits(1) \u003c\u003c i);\n    rev_mask |= (bits(not_flag) \u003c\u003c i);\n  }\n\n  int score(const Individual\u0026 ind) const {\n    bits x = (ind.x \u0026 mask) ^ (rev_mask);\n    if(x != 0) return 0;\n    else return 1;\n  }\n};\n\nstruct Problem {\n  std::vector\u003cConstrains\u003e cons;\n\n  Score score(const Individual\u0026 ind) const {\n    /*\n    std::vector\u003cint\u003e scores(cons.size());\n    int sum = 0;\n    for(int i = 0; i \u003c cons.size(); i++) {\n      scores[i] = cons[i].score(ind);\n      sum += scores[i];\n    }\n    return Score { scores, sum };\n    */\n    std::vector\u003cint\u003e scores;\n    int sum = 0;\n    for(int i = 0; i \u003c cons.size(); i += Clauses) {\n      int x = 0;\n      for(int j = i; j \u003c std::min((int)cons.size(), i + Clauses); j++) {\n        x += cons[j].score(ind);\n      }\n      //int res = x == 0 ? 0 : 1;\n      int res = x;\n      scores.push_back(res);\n      sum += res;\n    }\n    return Score { scores, sum };\n  }\n};\n\nint lexicase_selection(const std::vector\u003cstd::pair\u003cScore, Individual\u003e\u003e\u0026 gen, std::mt19937\u0026 mt) {\n  std::vector\u003cint\u003e idx(gen.size());\n  std::iota(idx.begin(), idx.end(), 0);\n  std::vector\u003cint\u003e cons(gen.front().first.val.size());\n  std::iota(cons.begin(), cons.end(), 0);\n  std::shuffle(cons.begin(), cons.end(), mt);\n\n  for(auto c: cons) {\n    int m = 1e9;\n    std::vector\u003cint\u003e next;\n    for(auto i: idx) {\n      if(m \u003e gen[i].first.val[c]) {\n        m = gen[i].first.val[c];\n        next.clear();\n      }\n      if(m \u003c gen[i].first.val[c]) continue;\n      next.push_back(i);\n    }\n    idx = std::move(next);\n    if(idx.size() == 1) {\n      break;\n    }\n  }\n  return idx[std::uniform_int_distribution\u003c\u003e(0, idx.size() - 1)(mt)];\n}\n\nvoid solve(const Problem\u0026 P) {\n  constexpr int Count = 200;\n  constexpr int Elite = 20;\n  constexpr int Gen = 500;\n  std::vector\u003cstd::pair\u003cScore, Individual\u003e\u003e gen(Count);\n\n  std::mt19937 mt(768);\n\n  {\n    std::uniform_int_distribution\u003cbits\u003e x_dist(0, (bits(1) \u003c\u003c N) - 1);\n    for(int i = 0; i \u003c Count; i++) {\n      gen[i].second.x = x_dist(mt);\n      gen[i].first = P.score(gen[i].second);\n      /*\n      if(i == 0) {\n        std::cerr \u003c\u003c std::bitset\u003cN\u003e(gen[i].second.x) \u003c\u003c std::endl;\n        for(int c = 0; c \u003c C; c++) {\n          std::cerr \u003c\u003c std::bitset\u003cN\u003e(gen[i].second.x \u0026 P.cons[c].mask) \u003c\u003c std::endl;\n        }\n      }\n      */\n    }\n  }\n\n  for(int g = 0; g \u003c Gen; g++) {\n    int MIN = 1e9;\n    int MAX = 0;\n    int sum = 0;\n    for(auto\u0026 [score, ind]: gen) {\n      int s = score.sum;\n      //std::cerr \u003c\u003c s \u003c\u003c \" \";\n      MIN = std::min(MIN, s);\n      MAX = std::max(MAX, s);\n      sum += s;\n    }\n    //std::cerr \u003c\u003c std::endl;\n    auto\u0026 min_ans = *std::min_element(gen.begin(), gen.end(), [](auto\u0026 a, auto\u0026 b) { return a.first.sum \u003c b.first.sum; });\n    std::cout \u003c\u003c gen.size() \u003c\u003c \"\\t\" \u003c\u003c g + 1 \u003c\u003c \"\\t\" \u003c\u003c MIN \u003c\u003c \"\\t\" \u003c\u003c MAX \u003c\u003c \"\\t\" \u003c\u003c double(sum) / gen.size() \u003c\u003c \"\\t\" \u003c\u003c std::bitset\u003cN\u003e(min_ans.second.x) \u003c\u003c std::endl;\n    std::vector\u003cstd::pair\u003cScore, Individual\u003e\u003e next;\n    {\n      std::vector\u003cint\u003e idx(gen.size());\n      std::iota(idx.begin(), idx.end(), 0);\n      std::nth_element(idx.begin(), idx.end() + Elite - 1, idx.end(), [\u0026](int i, int j) { return gen[i].first.sum \u003c gen[j].first.sum; });\n      for(int i = 0; i \u003c Elite; i++) {\n        next.push_back(gen[idx[i]]);\n        next.back().second.mutation(mt);\n        next.back().first = P.score(next.back().second);\n      }\n    }\n    for(int i = Elite; i \u003c Count; i++) {\n      int x = lexicase_selection(gen, mt);\n      int y = lexicase_selection(gen, mt);\n      auto ind = gen[x].second.crossover(gen[y].second, mt);\n      auto score = P.score(ind);\n      next.emplace_back(std::move(score), std::move(ind));\n    }\n    std::swap(next, gen);\n  }\n}\n\nint main() {\n  Problem P;\n  std::mt19937 mt(81);\n    \n  bits ans = std::uniform_int_distribution\u003cbits\u003e(0, (bits(1) \u003c\u003c N) - 1)(mt);\n  std::vector\u003cint\u003e idx(N);\n  std::iota(idx.begin(), idx.end(), 0);\n\n  for(int c = 0; c \u003c C; c++) {\n    Constrains con;\n    std::vector\u003cint\u003e sel(V);\n    std::sample(idx.begin(), idx.end(), sel.begin(), V, mt);\n    int ok = std::uniform_int_distribution\u003c\u003e(1, V)(mt);\n    for(int i = 0; i \u003c V; i++) {\n      int x = (ans \u003e\u003e sel[i]) \u0026 1;\n      con.add(sel[i], i \u003c ok ? 1 - x : x);\n    }\n    std::cerr \u003c\u003c std::bitset\u003cN\u003e(con.mask) \u003c\u003c \" \" \u003c\u003c std::bitset\u003cN\u003e(con.rev_mask) \u003c\u003c \" \" \u003c\u003c ((con.mask \u0026 ans) ^ con.rev_mask) \u003c\u003c std::endl;\n    P.cons.push_back(con);\n  }\n  std::cerr \u003c\u003c std::bitset\u003cN\u003e(ans) \u003c\u003c std::endl;\n  std::cin.get();\n  solve(P);\n}\n```\n\n{{\u003c/details\u003e}}\n\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/lyla_theme":{"title":"Hugoのテーマを変えました \u0026 lyla colorschemeについて","content":"\n\u003cstyle type=\"text/css\" media=\"screen\"\u003e\n.pallet h2 {\n border-bottom: initial;\n}\n\u003c/style\u003e\n\n## Hugoテーマ変えました\n\nま〜〜〜たテーマとか色とかいじくってた. 定期的にくる, この抑えられない衝動.  \n白はディスプレイにおいてはかなりの強調色なので, それが背景色とはどういうことやねんとは思っていたので, 思い切って自分が使っているカラースキームをHugoにも導入してやろうと思った感じです.\n\n## カラースキームについて\n\n[niuez/lyla.vim](https://github.com/niuez/lyla.vim)で公開しています\n\n\u003cdiv class=\"pallet\"\u003e\n\n\u003ch2 style=\"color: #6A6868; background-color: #242828\"\u003e#242828\u003c/h2\u003e\n\n- 背景色\n\n\u003ch2 style=\"color: #242828; background-color: #6A6868\"\u003e#6A6868\u003c/h2\u003e\n\n- グレー\n- ボーダー線を引いたり\n\n\u003ch2 style=\"color: #242828; background-color: #A4A4A4\"\u003e#A4A4A4\u003c/h2\u003e\n\n- 文章の色\n- でもあまり強調しない感じ\n\n\u003ch2 style=\"color: #242828; background-color: #737FC4\"\u003e#737FC4\u003c/h2\u003e\n\n- 深い青\n- 目立ってほしくないけどいてほしい単語に使う\n- `using`, `return` とか\n\n\u003ch2 style=\"color: #242828; background-color: #6F8EB3\"\u003e#6F8EB3\u003c/h2\u003e\n\n- ノーマルな青\n- Vimではこれを標準の文字の色にしている\n\n\u003ch2 style=\"color: #242828; background-color: #82BFF5\"\u003e#82BFF5\u003c/h2\u003e\n\n- 明るい青\n- ハイライトしたいものに使う\n- 検索結果のハイライトとか\n\n\u003ch2 style=\"color: #242828; background-color: #D06E3E\"\u003e#D06E3E\u003c/h2\u003e\n\n- 深い橙\n- 目立ってほしい単語に使う\n- `const`, `if`, `while`, `for`とか, \n\n\u003ch2 style=\"color: #242828; background-color: #BD8840\"\u003e#BD8840\u003c/h2\u003e\n\n- ノーマルな橙\n- 目立って欲しさNo.2の単語に使う\n\n\u003ch2 style=\"color: #242828; background-color: #E9A05A\"\u003e#E9A05A\u003c/h2\u003e\n\n- 明るい橙\n- 明るすぎて使う場所を見失っている(え？\n- `h1`にとりあえず使ってはいる\n\n\u003c/div\u003e\n\nNeovimではこんな感じです.\n\n![](/images/lyla/screenshot.png)\n\n「目立つ」とは言っても全体にまとまりを感じるこの感じが好き  でも個人差はありそうです.\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/multiple_transform":{"title":"倍数ゼータ・メビウス変換のメモ","content":"\n[約数ゼータ・メビウス変換]({{\u003c ref \"notes/divisor_transform2\"\u003e}})に続いて、倍数もメモします。\n\n## 倍数ゼータ・メビウス変換\n\n関数$f(n)$に対する倍数ゼータ変換は以下の定義です。$n | m$は「$m$は$n$の倍数」という意味で、$m$はmultipleのmです。\n\n$$\nF(n) = \\sum\\_{ n | m } f(m)\n$$\n\n\n倍数ゼータ変換の逆操作が倍数メビウス変換です。\n\n## 倍数ゼータ・メビウス変換の実装\n\n[高速ゼータ変換の約数版 O(N log(log(N))) - noshi91のメモ](https://noshi91.hatenablog.com/entry/2018/12/27/121649)を参考にすると早い実装が得られます。\n\n```cpp\ntemplate \u003cclass T\u003e\nvoid multiple_transform(vector\u003cT\u003e \u0026a) {\n    int n = a.size();\n    vector\u003cbool\u003e sieve(n, true);\n    for (int p = 2; p \u003c n; ++p) {\n        if (sieve[p]) {\n            for (int k = (n - 1) / p; k != 0; --k) {\n                sieve[k * p] = false;\n                a[k] += a[k * p];\n            }\n        }\n    }\n    for (int i = 0; ++i != n;) {\n        a[i] += a[0];\n    }\n}\n \ntemplate \u003cclass T\u003e\nvoid inverse_multiple_transform(vector\u003cT\u003e \u0026a) {\n    int n = a.size();\n    vector\u003cbool\u003e sieve(n, true);\n    for (int i = 0; ++i != n;) {\n        a[i] -= a[0];\n    }\n    for (int p = 2; p \u003c n; ++p) {\n        if (sieve[p]) {\n            for (int k = 1; k * p \u003c n; ++k) {\n                sieve[k * p] = false;\n                a[k] -= a[k * p];\n            }\n        }\n    }\n}\n```\n\n## gcdとの関連\n\n$f(n)$の定義が「$\\gcd$が$n$となる集合についての対応する値の総和」、つまり下のような式の形をしていたとしましょう。\n\n$$\nf(n) = \\sum\\_{n = \\gcd(S)} g(S)\n$$\n\nこれの倍数ゼータ変換$F(n)$を考えると\n\n$$\n\\begin{align}\nF(n) = \u0026 \\sum\\_{n | m} \\sum\\_{m = \\gcd(S)} g(S) \\\\\\\\\n= \u0026 \\sum\\_{n | \\gcd(S)} g(S) \\\\\\\\\n= \u0026 \\sum\\_{n | S\\_0, n | S\\_1, \\cdots} g(S) \\\\\\\\\n\\end{align}\n$$\n\nとなって、すべての要素が$n$を約数にもつような集合$S$についての計算になります。  \nこれがかなりいい性質で、数$A$の約数列挙は$O(\\sqrt A)$でできるので、\n$F(n)$の$n$それぞれについての計算が高速にできる場合があります。\n\n## AGC038 C - LCMs\n\n[AGC038 C - LCMs](https://atcoder.jp/contests/agc038/tasks/agc038_c)\n\n$$\n\\begin{align}\n\u0026 \\sum_{i = 0}^{N - 1} \\sum\\_{j = 0}^{i - 1} \\operatorname{lcm}(A\\_i, A\\_j) \\\\\\\\\n= \u0026 \\sum_{i = 0}^{N - 1} \\sum_{j = 0}^{i - 1} \\frac{A\\_i A\\_j}{\\gcd(A\\_i, A\\_j)} \\\\\\\\\n\\end{align}\n$$\n\nここで、$g = \\gcd(A\\_i, A\\_j)$となる$i, j \\\\ (i \u003c j)$それぞれについてまとめて計算することにします。\n\n$$\n\\begin{align}\n= \u0026 \\sum_{g} \\sum\\_{g = gcd(A\\_i, A\\_j), i \u003c j} \\frac{A\\_i A\\_j}{g} \\\\\\\\\n= \u0026 \\sum_{g} \\frac{1}{g} \\sum\\_{g = gcd(A\\_i, A\\_j), i \u003c j} A\\_i A\\_j \\\\\\\\\n\\end{align}\n$$\n\n$f(g) = \\sum\\_{g = gcd(A\\_i, A\\_j), i \u003c j} A\\_i A\\_j$として、これを倍数ゼータ変換をした$F(n)$を考えましょう。\n\n$$\n\\begin{align}\nF(n) \u0026 = \\sum\\_{n | m} f(m) \\\\\\\\\n\u0026 = \\sum\\_{n | m} \\sum\\_{m = \\gcd(A\\_i, A\\_j), i \u003c j} A\\_i A\\_j \\\\\\\\\n\u0026 = \\sum\\_{n | \\gcd(A\\_i, A\\_j), i \u003c j} A\\_i A\\_j \\\\\\\\\n\u0026 = \\sum\\_{n | A\\_i, n | A\\_j, i \u003c j} A\\_i A\\_j \\\\\\\\\n\u0026 = \\frac{1}{2} ((\\sum\\_{n | A\\_i} A\\_i)^2 - \\sum\\_{n | A\\_i} A\\_i^2)\n\\end{align}\n$$\n\n$\\sum\\_{n | A\\_i} A\\_i$と$\\sum\\_{n | A\\_i} A\\_i^2$は、各$i$について$A\\_i$の約数を列挙すれば計算できて、全体で$O(N \\sqrt A)$で計算できます。あとは計算した$F(n)$を倍数メビウス変換にかければ$f(n)$が得られます。\n\n[提出コード](https://atcoder.jp/contests/agc038/submissions/31088763)\n\n```cpp\nconstexpr i64 MAX = 1e6 + 1;\n \nint main() {\n  i64 N;\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n  cin \u003e\u003e N;\n  vector\u003ci64\u003e A(N);\n  rep(i,0,N) cin \u003e\u003e A[i];\n  vector\u003cfp\u003e S(MAX);\n \n  vector\u003cfp\u003e ans(MAX);\n \n  rep(i,0,N) {\n    for(i64 d = 1; d * d \u003c= A[i]; d++) {\n      if(A[i] % d == 0) {\n        S[d] += fp(A[i]);\n        ans[d] -= A[i] * A[i];\n        if(A[i] / d != d) {\n          S[A[i] / d] += fp(A[i]);\n          ans[A[i] / d] -= A[i] * A[i];\n        }\n      }\n    }\n  }\n  fp i2 = fp(2).inv();\n  rep(g,1,MAX) {\n    ans[g] += S[g] * S[g];\n    ans[g] *= i2;\n  }\n \n  inverse_multiple_transform(ans);\n \n  fp res;\n  rep(g,1,MAX) {\n    res += fp(g).inv() * ans[g];\n  }\n  cout \u003c\u003c res \u003c\u003c endl;\n}\n```\n\n## ちなみに...\n\n$\\sum\\_{n | A\\_i} A\\_i$は倍数ゼータ変換の形をしているので、この計算を倍数ゼータ変換して求めることで高速に計算できます。これがいわゆる$\\gcd$畳み込みです。\n\n[提出コード](https://atcoder.jp/contests/agc038/submissions/31088850)\n\n\n\n```cpp\nconstexpr i64 MAX = 1e6 + 1;\n \nint main() {\n  i64 N;\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n  cin \u003e\u003e N;\n  vector\u003ci64\u003e A(N);\n  rep(i,0,N) cin \u003e\u003e A[i];\n  vector\u003cfp\u003e S(MAX);\n \n  rep(i,0,N) {\n    S[A[i]] += A[i];\n  }\n  multiple_transform(S);\n \n  rep(g,1,MAX) {\n    S[g] = S[g] * S[g];\n  }\n \n  inverse_multiple_transform(S);\n \n  fp res;\n  rep(g,1,MAX) {\n    res += fp(g).inv() * S[g];\n  }\n  rep(i,0,N) {\n    res -= A[i];\n  }\n  cout \u003c\u003c res / fp(2) \u003c\u003c endl;\n}\n```\n\n## ちなみに...2\n\n約数を列挙する部分でosa\\_k法を用いるとめちゃ速くなります。\n\n[提出コード](https://atcoder.jp/contests/agc038/submissions/31096016)\n\nosa\\_kの実装は[えびちゃんのエラトステネスの篩に基づく高速な素因数分解 - Qiita](https://qiita.com/rsk0315_h4x/items/ff3b542a4468679fb409)を参考にしました。\n\n```cpp\nstruct osa_k {\n  using int_type = int;\n  std::vector\u003cint_type\u003e min_fact;\n \n  // O(NlogN)\n  static std::vector\u003cint_type\u003e min_prime_factor(int n) {\n    std::vector\u003cint_type\u003e res(n);\n    std::iota(std::begin(res), std::end(res), 0);\n    for(int i = 2; i * i \u003c n; i++) {\n      if(res[i] \u003c i) continue;\n      for(int j = i * i; j \u003c n; j += i) {\n        if(res[j] == j) res[j] = i;\n      }\n    }\n    return res;\n  }\n \n  void build(int n) {\n    min_fact = min_prime_factor(n);\n  }\n \n  // O(logN)\n  std::vector\u003cstd::pair\u003cint_type, int\u003e\u003e prime_factors(int n) const {\n    std::vector\u003cstd::pair\u003cint_type, int\u003e\u003e res;\n    while(n \u003e 1) {\n      if(res.empty() || res.back().first != min_fact[n]) {\n        res.push_back({ min_fact[n], 0 });\n      }\n      res.back().second++;\n      n /= min_fact[n];\n    }\n    return res;\n  }\n  \n  // The divisors are not sorted\n  // O(logN + |divisors|)\n  template\u003cclass F\u003e\n  void enumerate_divisors(int n, F f) const {\n    std::vector\u003cstd::pair\u003cint_type, int\u003e\u003e prime_facts = prime_factors(n);\n    if(prime_facts.empty()) {\n      f(1);\n      return;\n    }\n    std::vector\u003cint\u003e cnt(prime_facts.size());\n    std::vector\u003cint\u003e acc(prime_facts.size(), 1);\n    while(true){\n      f(acc.front());\n      int i = 0;\n      for(; i \u003c prime_facts.size(); i++) {\n        if((cnt[i]++) == prime_facts[i].second) {\n          cnt[i] = 0;\n        }\n        else {\n          acc[i] *= prime_facts[i].first;\n          break;\n        }\n      }\n      if(i == prime_facts.size()) {\n        break;\n      }\n      while(i --\u003e 0) {\n        acc[i] = acc[i + 1];\n      }\n    }\n  }\n};\n\n...\n\nint main() {\n  i64 N;\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n  cin \u003e\u003e N;\n  vector\u003ci64\u003e A(N);\n  rep(i,0,N) cin \u003e\u003e A[i];\n \n  osa_k osa;\n  osa.build(MAX);\n  vector\u003cfp\u003e S(MAX);\n \n  vector\u003cfp\u003e ans(MAX);\n \n  rep(i,0,N) {\n    osa.enumerate_divisors(A[i], [\u0026](int d) {\n        S[d] += fp(A[i]);\n        ans[d] -= fp(A[i]) * fp(A[i]);\n    });\n  }\n  fp i2 = fp(2).inv();\n  rep(g,1,MAX) {\n    ans[g] += S[g] * S[g];\n    ans[g] *= i2;\n  }\n \n  inverse_multiple_transform(ans);\n \n  fp res;\n  rep(g,1,MAX) {\n    res += fp(g).inv() * ans[g];\n  }\n  cout \u003c\u003c res \u003c\u003c endl;\n}\n```\n\n\n## ABC248 G - GCD cost on the tree\n\n[ABC248 G - GCD cost on the tree](https://atcoder.jp/contests/abc248/tasks/abc248_g)\n\n$P(i, j)$を$(i, j)$パス上の頂点の$A$の値の集合、$d(i, j)$を$(i, j)$パスの長さとすると、\n\n$$\n\\begin{align}\n\\sum\\_{i \u003c j} (d(i, j) + 1) \\gcd(P(i, j))\n\\end{align}\n$$\n\nが答えです。ここから変形していきます。\n\n$$\n\\begin{align}\n= \u0026 \\sum\\_{g} \\sum\\_{g = \\gcd(P(i, j)), i \u003c j} (d(i, j) + 1) g \\\\\\\\\n= \u0026 \\sum\\_{g} g \\sum\\_{g = \\gcd(P(i, j)), i \u003c j} (d(i, j) + 1) \\\\\\\\\n\\end{align}\n$$\n\n$f(g) = \\sum\\_{g = \\gcd(P(i, j)), i \u003c j} (d(i, j) + 1)$として、これの倍数ゼータ変換$F(n)$を考えましょう。\n\n$$\n\\begin{align}\nF(n) = \u0026 \\sum\\_{n | m} \\sum\\_{m = \\gcd(P(i, j)), i \u003c j} (d(i, j) + 1) \\\\\\\\\n= \u0026 \\sum\\_{n | \\gcd(P(i, j)), i \u003c j} (d(i, j) + 1) \\\\\\\\\n= \u0026 \\sum\\_{P(i, j)の全ての要素はnを約数にもつ, i \u003c j} (d(i, j) + 1)\n\\end{align}\n$$\n\nなので、$A\\_i$が$n$を約数にもつような頂点$i$だけからなるグラフを考えると計算できそうです。パスの長さの総和は、各辺を合計何回通るかで計算できます。  \ndfs戻りがけを意識して実装すると簡単です。\n\nあとは同様に$F(n)$を倍数メビウス変換をすれば、$f(n)$が求まります。\n\n[提出コード](https://atcoder.jp/contests/abc248/submissions/31087608)\n\n```cpp\ni64 N;\nvector\u003ci64\u003e A;\nvector\u003cvector\u003cint\u003e\u003e G;\nvector\u003cvector\u003cint\u003e\u003e dv(1e5 + 1);\n \nvector\u003cint\u003e vis;\n \nvoid dfs(int v, int p, int g, vector\u003ci64\u003e\u0026 cnt) {\n  vis[v] = 1;\n  i64 now = 1;\n  for(auto u: G[v]) {\n    if(u == p) continue;\n    if(A[u] % g != 0) continue;\n    dfs(u, v, g, cnt);\n    now += cnt.back();\n  }\n  cnt.push_back(now);\n}\n\nint main() {\n  cin \u003e\u003e N;\n  A.resize(N);\n  G.resize(N);\n  rep(i,0,N) cin \u003e\u003e A[i];\n  rep(i,0,N - 1) {\n    i64 u, v;\n    cin \u003e\u003e u \u003e\u003e v;\n    u--;\n    v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  rep(i,0,N) {\n    for(i64 d = 1; d * d \u003c= A[i]; d++) {\n      if(A[i] % d == 0) {\n        dv[d].push_back(i);\n        if(A[i] / d != d) {\n          dv[A[i] / d].push_back(i);\n        }\n      }\n    }\n  }\n  vector\u003cfp\u003e ans(dv.size());\n  vis.resize(N, 0);\n  rep(g,1,dv.size()) {\n    for(auto v: dv[g]){\n      if(vis[v] == 0) {\n        vector\u003ci64\u003e cnt;\n        dfs(v, -1, g, cnt);\n        rep(i,0,cnt.size() - 1) {\n          ans[g] += fp(cnt[i]) * fp(cnt.back() - cnt[i]);\n        }\n        ans[g] += fp(cnt.back()) * fp(cnt.back() - 1) / fp(2);\n      }\n    }\n    for(auto v: dv[g]) {\n      vis[v] = 0;\n    }\n  }\n  inverse_multiple_transform(ans);\n  fp res;\n  rep(i,1,dv.size()) {\n    res += fp(i) * ans[i];\n  }\n  cout \u003c\u003c res \u003c\u003c endl;\n}\n```\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/nsgaii_multi_knapsack":{"title":"NSGA-IIによるMulti Knapsack Problemへのアプローチ","content":"\n# 概要\n\n\n[前回勉強したLexicase Selection入門の話]({{\u003c ref \"/notes/lexicase_booleanCSP\" \u003e}})では、多目的関数に対する最適化を行った。\n今回は、同じく多目的関数に対する手法であるNon-dominated Sorting Genetic Algorithm II(NSGA-II)を勉強したのでメモしておく。\n\n参考\n\n1. [A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II](https://web.njit.edu/~horacio/Math451H/download/2002-6-2-DEB-NSGA-II.pdf)\n2. [多数目的最適化問題における進化型多目的最適化 アルゴリズムの問題点とその改良手法に関する考察](https://www.jstage.jst.go.jp/article/iscie/22/6/22_6_220/_pdf)\n3. [多目的最適化問題のNSGA-Ⅱを勉強したの整理しました - Qiita](https://qiita.com/DS27/items/025a52b26a9f2471e67c)\n4. [多目的な最適化問題を解くためにNSGA-Ⅱを解説する - Qiita](https://qiita.com/Taichi-Furukawa/items/a7a0982cc20a401133c0)\n\n参考2で示されているが、目的関数が増えるほどこのアルゴリズムが弱っていく。こういうときはlexicaseが有効になるらしい。(ICPCのコーチ曰く)\n\n# Non-dominated Sorting\n\n日本語では非優劣ソートと呼ばれる。解の中でパレート最適な集合をrank0として、それを取り除き再帰的にrank1, ...を決めていくソートである。これを用いて多目的関数に対するElisitmを実現する。\n参考1の論文では$O(M N^2)$での実装が示されていて、それを用いて以下では実装している。\n\n# Crowding Distance\n\n日本語では混雑度といい、各個体の周囲にある個体がどの程度密集しているかを評価するために用いる。計算方法は参考1で示されていて、以下である。\n\n1. すべての個体の混雑度を0で初期化する\n2. 1番目の評価基準$f$について以下を行う\n3. $f$による評価で個体をソートする\n4. ソートした時の両端の個体(最小値と最大値を持つ個体)の混雑度に$\\infty$を加算する\n5. それ以外のi番目の個体の混雑度には$\\frac{f(i + 1) - f(i - 1)}{f^{\\mathrm{max}} - f^{\\mathrm{min}}}$を加算する\n6. 2番目以降の評価基準についても2~5を行う\n\n混雑度が大きいほど、周囲に同じような個体が存在していないことになる。\n\n# NSGA-IIの流れ\n\nNSGAはNon-dominated SortingとCrowding Distanceを用いて以下のように世代更新を行う。\n\n- $P$: 現在の世代\n- $Q$: 次の世代、最初は空\n- $N=|P|$\n- $E$: Elitismで残す個体数\n\n1. $P$に対してNon-dominated Sorting、rank$i$の個体の集合を$F_i$とする\n2. $i = 0$から$|R| + |F_i| \\leq E$なら$R := R \\cup $F_i$\n3. $F_i$に対してCrowding Distanceを計算し、混雑度が高い個体から$|R| = E$になるまで$R$に追加する\n4. $Q := R$\n5. $R$から(Rank, Crowding Distance)のタプルによる順序によってトーナメント選択を行い、交叉、突然変異を行った個体を$Q$に追加する\n6. $|R| + |Q| = N$になるまで追加する\n\n# 実装\n\nMulti Knapsack Problem(参考2)に対してNSGA-IIを適用した実装を以下に示す。このようなパレート最適な解が見つかった。\n\n![](./notes/multikp.png)\n\n{{\u003c details 提出コード \u003e}}\n```cpp\n#include \u003cvector\u003e\n#include \u003ciostream\u003e\n#include \u003cnumeric\u003e\n#include \u003crandom\u003e\n\ntemplate\u003cclass T\u003e\nstd::vector\u003cstd::vector\u003cint\u003e\u003e non_dominated_sort(const std::vector\u003cstd::vector\u003cT\u003e\u003e\u0026 p, int cnt) {\n  const int N = p.size();\n  const int M = p.empty() ? 0 : p.front().size();\n  std::vector\u003cint\u003e n(N);\n  std::vector\u003cstd::vector\u003cint\u003e\u003e S(N);\n  std::vector\u003cstd::vector\u003cint\u003e\u003e F(1);\n  for(int i = 0; i \u003c N; i++) {\n    for(int j = i + 1; j \u003c N; j++) {\n      int ic = 0;\n      int id = 0;\n      int jc = 0;\n      int jd = 0;\n      for(int k = 0; k \u003c M; k++) {\n        T x = p[i][k];\n        T y = p[j][k];\n        if(x \u003c= y){\n          ic++;\n          if(x \u003c y) {\n            id++;\n          }\n        }\n        if(x \u003e= y){\n          jc++;\n          if(x \u003e y) {\n            jd++;\n          }\n        }\n      }\n      if(ic == M \u0026\u0026 id \u003e 0) {\n        S[i].push_back(j);\n        n[j]++;\n      }\n      if(jc == M \u0026\u0026 jd \u003e 0) {\n        S[j].push_back(i);\n        n[i]++;\n      }\n    }\n    if(n[i] == 0) {\n      cnt--;\n      F[0].push_back(i);\n    }\n  }\n  while(F.back().size() \u003e 0 \u0026\u0026 cnt \u003e 0) {\n    std::vector\u003cint\u003e Q;\n    for(auto i: F.back()) {\n      for(auto j: S[i]) {\n        n[j]--;\n        if(n[j] == 0) {\n          Q.push_back(j);\n          cnt--;\n        }\n      }\n    }\n    F.push_back(std::move(Q));\n  }\n  return F;\n}\n\ntemplate\u003cclass T\u003e\nstd::vector\u003cT\u003e crowding_distances(const std::vector\u003cstd::vector\u003cT\u003e\u003e\u0026 p, const T INF) {\n  const int N = p.size();\n  const int M = p.empty() ? 0 : p.front().size();\n  std::vector\u003cT\u003e dist(p.size());\n  std::vector\u003cint\u003e idx(N);\n  std::iota(idx.begin(), idx.end(), 0);\n  for(int m = 0; m \u003c M; m++) {\n    std::sort(idx.begin(), idx.end(), [\u0026](int i, int j) { return p[i][m] \u003c p[j][m]; });\n    dist[idx.front()] = INF;\n    dist[idx.back()] = INF;\n    T fmin = p[idx.front()][m];\n    T fmax = p[idx.back()][m];\n    for(int k = 1; k + 1 \u003c idx.size(); k++) {\n      dist[idx[k]] += (p[idx[k + 1]][m] - p[idx[k - 1]][m]) / (fmax - fmin);\n    }\n  }\n  for(int i = 0; i \u003c dist.size(); i++) {\n    if(dist[i] \u003e= INF) dist[i] = INF;\n  }\n  return dist;\n}\n\nstruct Individual {\n  std::vector\u003cint\u003e x;\n\n  Individual crossover(const Individual\u0026 p, std::mt19937\u0026 mt) const {\n    static std::bernoulli_distribution dist(0.5);\n    std::vector\u003cint\u003e next(x.size());\n    for(int i = 0; i \u003c x.size(); i++) {\n      next[i] = dist(mt) ? x[i] : p.x[i];\n    }\n    return Individual { next };\n  }\n\n  void mutation(std::mt19937\u0026 mt) {\n    static std::bernoulli_distribution dist(0.002);\n    for(int i = 0; i \u003c x.size(); i++) {\n      if(dist(mt)) {\n        x[i] ^= 1;\n      }\n    }\n  }\n};\n\nstruct Subject {\n  std::vector\u003cdouble\u003e v;\n  std::vector\u003cdouble\u003e w;\n  double c;\n  double sum_v;\n\n  void build() {\n    sum_v = std::accumulate(v.begin(), v.end(), 0.0);\n  }\n\n  double score(const Individual\u0026 ind) const {\n    return sum_v - std::inner_product(v.begin(), v.end(), ind.x.begin(), 0.0);\n  }\n};\n\nusing Score = std::vector\u003cdouble\u003e;\n\nstruct MultiKnapsack {\n  std::vector\u003cSubject\u003e subs;\n  std::vector\u003cint\u003e fix_order;\n  int N;\n\n  void build() {\n    N = subs.front().v.size();\n    std::vector\u003cdouble\u003e q(subs.front().v.size(), 0);\n    for(int i = 0; i \u003c subs.size(); i++) {\n      for(int j = 0; j \u003c subs[i].v.size(); j++) {\n        q[j] = std::max(q[j], subs[i].v[j] / subs[i].w[j]);\n      }\n    }\n    fix_order.resize(q.size());\n    std::iota(fix_order.begin(), fix_order.end(), 0);\n    std::sort(fix_order.begin(), fix_order.end(), [\u0026](int i, int j) { return q[i] \u003c q[j]; });\n  }\n\n  void fix_to_feasible(Individual\u0026 ind) const {\n    std::vector\u003cdouble\u003e weight(subs.size());\n    std::vector\u003cint\u003e bad_idx;\n    for(int i = 0; i \u003c subs.size(); i++) {\n      weight[i] = std::inner_product(subs[i].w.begin(), subs[i].w.end(), ind.x.begin(), 0.0);\n      if(subs[i].c \u003c weight[i]) {\n        bad_idx.push_back(i);\n      }\n    }\n    for(auto j: fix_order) {\n      if(bad_idx.size() == 0) break;\n      if(ind.x[j] == 0) continue;\n      int k = 0;\n      ind.x[j] = 0;\n      while(k \u003c bad_idx.size()) {\n        int i = bad_idx[k];\n        weight[i] -= subs[i].w[j];\n        if(subs[i].c \u003c weight[i]) {\n          k++;\n          continue;\n        }\n        else {\n          if(k + 1 \u003c bad_idx.size()) {\n            std::swap(bad_idx[k], bad_idx.back());\n          }\n          bad_idx.pop_back();\n        }\n      }\n    }\n  }\n\n  Score score(const Individual\u0026 ind) const {\n    Score scores(subs.size());\n    for(int i = 0; i \u003c subs.size(); i++) {\n      scores[i] = subs[i].score(ind);\n    }\n    return scores;\n  }\n};\n\nvoid solve(const MultiKnapsack\u0026 knap) {\n  constexpr int Cnt = 200;\n  constexpr int Save = 100;\n  constexpr int Gen = 20000;\n  constexpr int Tounament = 2;\n\n  std::mt19937 mt(786);\n\n  std::vector\u003cIndividual\u003e gen(Cnt);\n  std::vector\u003cScore\u003e scores(Cnt);\n  {\n    std::uniform_int_distribution\u003cint\u003e dist(0, 1);\n    for(int i = 0; i \u003c Cnt; i++) {\n      std::vector\u003cint\u003e x(knap.N);\n      for(int j = 0; j \u003c knap.N; j++) {\n        x[j] = dist(mt);\n      }\n      gen[i].x = std::move(x);\n      knap.fix_to_feasible(gen[i]);\n      scores[i] = knap.score(gen[i]);\n    }\n  }\n\n  for(int g = 0; g \u003c Gen; g++) {\n    auto F = non_dominated_sort(scores, Save);\n\n    {\n      double max_sum = 0;\n      std::vector\u003cdouble\u003e maxs(knap.subs.size());\n      for(int i = 0; i \u003c Cnt; i++) {\n        max_sum = std::max(max_sum, std::accumulate(scores[i].begin(), scores[i].end(), 0.0));\n        for(int j = 0; j \u003c scores[i].size(); j++) {\n          maxs[j] = std::max(maxs[j], scores[i][j]);\n        }\n      }\n      double sum_max = std::accumulate(maxs.begin(), maxs.end(), 0.0);\n      std::cerr \u003c\u003c g \u003c\u003c \"\\t\" \u003c\u003c F[0].size() \u003c\u003c \"/\" \u003c\u003c F.size() \u003c\u003c \"\\t\" \u003c\u003c max_sum \u003c\u003c \"\\t\" \u003c\u003c sum_max \u003c\u003c std::endl;\n    }\n    \n    std::vector\u003cIndividual\u003e next;\n    std::vector\u003cScore\u003e next_scores;\n    std::vector\u003cint\u003e rank;\n    std::vector\u003cdouble\u003e crowd;\n    for(int r = 0; r \u003c F.size(); r++) {\n      std::vector\u003cScore\u003e p;\n      for(auto i: F[r]) {\n        p.push_back(scores[i]);\n      }\n      auto cr = crowding_distances(p, 1e9);\n      std::vector\u003cint\u003e idx(cr.size());\n      std::iota(idx.begin(), idx.end(), 0);\n      int need = std::min((int)idx.size(), std::max(0, Save - (int)next.size()));\n\n      if(need \u003c idx.size()) {\n        std::sort(idx.begin(), idx.end(), [\u0026](int i, int j) { return cr[i] \u003e cr[j]; });\n      }\n      for(int k = 0; k \u003c need; k++) {\n        //std::cerr \u003c\u003c cr[idx[k]] \u003c\u003c \" \\n\"[k + 1 == need];\n        next.push_back(std::move(gen[F[r][idx[k]]]));\n        next_scores.push_back(std::move(scores[F[r][idx[k]]]));\n        rank.push_back(r);\n        crowd.push_back(cr[idx[k]]);\n      }\n    }\n\n    std::vector\u003cint\u003e idx(Save);\n    std::iota(idx.begin(), idx.end(), 0);\n    auto tounament_selection = [\u0026]() {\n      std::vector\u003cint\u003e vs(Tounament);\n      std::sample(idx.begin(), idx.end(), vs.begin(), Tounament, mt);\n      return *std::max_element(vs.begin(), vs.end(), [\u0026](int i, int j) {\n          if(rank[i] != rank[j]) return rank[i] \u003e rank[j];\n          else return crowd[i] \u003c crowd[j]; \n      });\n    };\n    std::bernoulli_distribution crossover_dist(0.8);\n    for(int i = Save; i \u003c Cnt; i++) {\n      if(crossover_dist(mt)) {\n        int x = tounament_selection();\n        int y = tounament_selection();\n        //std::cerr \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c std::endl;\n        auto z = next[x].crossover(next[y], mt);\n        knap.fix_to_feasible(z);\n        next_scores.push_back(knap.score(z));\n        next.push_back(std::move(z));\n      }\n      else {\n        int x = tounament_selection();\n        auto z = next[x];\n        z.mutation(mt);\n        knap.fix_to_feasible(z);\n        next_scores.push_back(knap.score(z));\n        next.push_back(std::move(z));\n      }\n    }\n\n    std::swap(next, gen);\n    std::swap(next_scores, scores);\n  }\n\n  {\n    auto F = non_dominated_sort(scores, scores.size());\n    std::sort(F[0].begin(), F[0].end(), [\u0026](int i, int j) { return scores[i] \u003c scores[j]; });\n    for(auto i: F[0]) {\n      for(int j = 0; j \u003c scores[i].size(); j++) {\n        std::cerr \u003c\u003c scores[i][j] \u003c\u003c \"\\t\";\n      }\n      /*\n      for(int j = 0; j \u003c gen[i].x.size(); j++) {\n        std::cerr \u003c\u003c gen[i].x[j];\n      }\n      */\n      std::cerr \u003c\u003c std::endl;\n    }\n  }\n}\n\nint main() {\n  std::mt19937 mt(81);\n\n  MultiKnapsack multi;\n\n  constexpr int Item = 500;\n  constexpr int Subs = 3;\n\n  for(int i = 0; i \u003c Subs; i++) {\n    Subject sub;\n    std::uniform_real_distribution\u003cdouble\u003e v_dist(1, 100);\n    std::uniform_real_distribution\u003cdouble\u003e c_dist(5 * Item, 10 * Item);\n    sub.v.resize(Item);\n    sub.w.resize(Item);\n    for(int i = 0; i \u003c Item; i++) {\n      sub.v[i] = v_dist(mt);\n      sub.w[i] = v_dist(mt);\n    }\n    sub.c = c_dist(mt);\n    sub.build();\n    std::cerr \u003c\u003c sub.c \u003c\u003c \" \" \u003c\u003c sub.sum_v \u003c\u003c \" \" \u003c\u003c std::accumulate(sub.w.begin(), sub.w.end(), 0.0) \u003c\u003c std::endl;\n    multi.subs.push_back(std::move(sub));\n  }\n  multi.build();\n\n  solve(multi);\n}\n```\n\n{{\u003c/details\u003e}}\n\n\n\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/oyamac20":{"title":"OyamaC'20 解説","content":"\n小山高専で, mitsuさん原案のコンテスト[OyamaC](https://www.hackerrank.com/oyamac)が行われました. testerを担当したので, 解説を書いておきます.\n\n# fizzbuzz\n\nfizzbuzzは書けますか？`N % 15`から書くとスムーズです.\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\nint main() {\n  i64 N;\n  cin \u003e\u003e N;\n  if(N % 15 == 0) cout \u003c\u003c \"fizzbuzz\" \u003c\u003c endl;\n  else if(N % 3 == 0) cout \u003c\u003c \"fizz\" \u003c\u003c endl;\n  else if(N % 5 == 0) cout \u003c\u003c \"buzz\" \u003c\u003c endl;\n  else cout \u003c\u003c N \u003c\u003c endl;\n}\n```\n\n# tiktak\n\n秒の単位換算です. `3600, 60`で割ったあまりを計算していけばいいです.\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\nint main() {\n  i64 N;\n  cin \u003e\u003e N;\n  cout \u003c\u003c N / 3600 \u003c\u003c endl;\n  N %= 3600;\n  cout \u003c\u003c N / 60 \u003c\u003c endl;\n  cout \u003c\u003c N % 60 \u003c\u003c endl;\n}\n```\n\n# sumsumsum\n\nみつみつみつみたいですね(は？)  これは, $x, y$を$D$をオーバーしない範囲で考えてあげれば, $z$が決まります.\n実は, 原案は$1 \\le A, B, C, D \\le 10^6$でした. あなたは解けますか？\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) \u003c (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nint main() {\n  i64 N = 3;\n  vector\u003ci64\u003e A(N);\n  rep(i,0,N) {\n    cin \u003e\u003e A[i];\n  }\n  i64 D;\n  cin \u003e\u003e D;\n\n  vector\u003cvector\u003ci64\u003e\u003e dp(N + 1, vector\u003ci64\u003e(D + 1, 0));\n  dp[0][0] = 1;\n  rep(i,0,N) {\n    rep(j,0,D + 1) {\n      if(j \u003e= A[i]) {\n        dp[i + 1][j] = dp[i][j] + dp[i + 1][j - A[i]];\n      }\n      else {\n        dp[i + 1][j] = dp[i][j];\n      }\n    }\n  }\n  cout \u003c\u003c dp[N][D] \u003c\u003c endl;\n}\n```\n\n# uniform liner sushi\n\nこれは蟻本にも書かれている, 区間スゲジューリング問題ですね. 後ろをなるべく小さくするように取る貪欲で解くことができます.\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) \u003c (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nint main() {\n  i64 N;\n  cin \u003e\u003e N;\n  std::vector\u003cpair\u003ci64, i64\u003e\u003e vec;\n  rep(i,0,N) {\n    i64 s, t;\n    cin \u003e\u003e s \u003e\u003e t;\n    vec.push_back({ s + t, s });\n  }\n\n  sort(all(vec));\n\n\n  vector\u003ci64\u003e ne(1, 0);\n  i64 ans = 0;\n  rep(i,0,N) {\n    if(ne[0] \u003c= vec[i].second) {\n      ne[0] = vec[i].first;\n      ans++;\n    }\n  }\n  cout \u003c\u003c ans \u003c\u003c endl;\n}\n```\n\n# rot and rot\n\nこれが最後の砦だと思ってたんですけど, 皆さんどうでしたか？  \n僕は行列を用いて移動を表現しました. \n\n\n\u003cdiv\u003e\n$$\n\\left(\n  \\begin{array}{c}\n    S \u0026 1\n  \\end{array}\n\\right)\n$$\n\u003c/div\u003e\n\nに,\n\n\u003cdiv\u003e\n$$\n\\left(\n  \\begin{array}{c}\n    A + 1 \u0026 1 \\\\\n    B \u0026 0\n  \\end{array}\n\\right)\n$$\n\u003c/div\u003e\n\nを掛けると, 1ステップです. なので, $N$ステップは, \n\n\u003cdiv\u003e\n$$\n\\left(\n  \\begin{array}{c}\n    S \u0026 1\n  \\end{array}\n\\right)\n\\left(\n  \\begin{array}{c}\n    A + 1 \u0026 0 \\\\\n    B \u0026 1\n  \\end{array}\n\\right) ^ N\n= \n\\left(\n  \\begin{array}{c}\n    S \u0026 1\n  \\end{array}\n\\right)\n\\left(\n  \\begin{array}{c}\n    (A + 1) ^ N \u0026 0 \\\\\n    ((A + 1)^N - 1) / ((A + 1) - 1) * B \u0026 1\n  \\end{array}\n\\right) ^ N\n$$\n\u003c/div\u003e\n\nです.  $A = 0$に注意が必要です. 行列累乗でも間に合うと思います.\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) \u003c (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nconst i64 MOD = 1e9 + 7;\n\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n\ntemplate\u003ci64 M\u003e\nconstexpr i64 euinv(i64 val) {\n    i64 a = M, b = val;\n    i64 x = 0, u = 1;\n    while (b) {\n        i64 t = a / b;\n        swap(a -= t * b, b);\n        swap(x -= t * u, u);\n    }\n    return x \u003c 0 ? x + M : x;\n}\n\ntemplate\u003ci64 M\u003e\nstruct modint {\n  i64 a;\n  constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}\n  constexpr i64 value() const noexcept { return a; }\n  constexpr modint inv() const noexcept { return modint(euinv\u003cM\u003e(a)); }\n  constexpr modint pow(i64 r) const noexcept {\n    modint ans(1);\n    modint aa = *this;\n    while(r) {\n      if(r \u0026 1) {\n        ans *= aa;\n      }\n      aa *= aa;\n      r \u003e\u003e= 1;\n    }\n    return ans;\n  }\n  constexpr modint\u0026 operator+=(const modint r) noexcept {\n    a += r.a;\n    if(a \u003e= M) a -= M;\n    return *this;\n  }\n  constexpr modint\u0026 operator=(const i64 r) {\n    a = (r % M + M) % M;\n    return *this;\n  }\n  constexpr modint\u0026 operator-=(const modint r) noexcept {\n    a -= r.a;\n    if(a \u003c 0) a += M;\n    return *this;\n  }\n  constexpr modint\u0026 operator*=(const modint r) noexcept {\n    a = a * r.a % M;\n    return *this;\n  }\n  constexpr modint\u0026 operator/=(modint r) noexcept {\n    i64 ex = M - 2;\n    while(ex) {\n      if(ex \u0026 1) {\n        *this *= r;\n      }\n      r *= r;\n      ex \u003e\u003e= 1;\n    }\n    return *this;\n  }\n\n  constexpr modint operator+(const modint r) const {\n    return modint(*this) += r;\n  }\n  constexpr modint operator-(const modint r) const {\n    return modint(*this) -= r;\n  }\n  constexpr modint operator*(const modint r) const {\n    return modint(*this) *= r;\n  }\n  constexpr modint operator/(const modint r) const {\n    return modint(*this) /= r;\n  }\n\n  constexpr bool operator!=(const modint r) const {\n    return this-\u003evalue() != r.value();\n  }\n\n};\n\ntemplate\u003cconst i64 M\u003e\nstd::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const modint\u003cM\u003e\u0026 m) {\n  os \u003c\u003c m.value();\n  return os;\n}\n\nusing fp = modint\u003cMOD\u003e;\n\nint main() {\n  i64 S, A, B, N;\n  cin \u003e\u003e S \u003e\u003e A \u003e\u003e B \u003e\u003e N;\n  A++;\n\n  if(A == 1) {\n    cout \u003c\u003c fp(S) + fp(B) * fp(N) \u003c\u003c endl;\n  }else {\n    /*\n     * p = 10^9 + 7, F_pでの演算を考える\n     * \n     * [S  1] * [ A + 1  0  ]^N\n     *          [   B    1  ]\n     *\n     * = [S  1] * [ (A + 1)^N                              0 ]\n     *            [ ((A + 1)^N - 1) / ((A + 1) - 1) * B    1 ]\n     */\n    cout \u003c\u003c fp(S) * fp(A).pow(N) + (fp(A).pow(N) - fp(1)) / (fp(A) - fp(1)) * fp(B) \u003c\u003c endl;\n  }\n\n}\n```\n\n# uniform liner sushi 2\n\n2なのでふたつです. 基本区間スケジュールでやりますが, なるべく寿司が食べ終わるのが遅い方を優先的に食べさせるようにするといいです.\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) \u003c (e);(i)++)\n#define all(x) x.begin(),x.end()\nint main() {\n  i64 N;\n  cin \u003e\u003e N;\n  std::vector\u003cpair\u003ci64, i64\u003e\u003e vec;\n  rep(i,0,N) {\n    i64 s, t;\n    cin \u003e\u003e s \u003e\u003e t;\n    vec.push_back({ s + t, s });\n  }\n\n  sort(all(vec));\n\n\n  vector\u003ci64\u003e ne(2, 0);\n  i64 ans = 0;\n  rep(i,0,N) {\n    if(ne[1] \u003c= vec[i].second) {\n      ne[1] = vec[i].first;\n      ans++;\n    }\n    else if(ne[0] \u003c= vec[i].second) {\n      ne[0] = vec[i].first;\n      std::swap(ne[0], ne[1]);\n      ans++;\n    }\n  }\n  cout \u003c\u003c ans \u003c\u003c endl;\n}\n```\n\n# storage\n\nちょうど満杯, なので容量の情報は正確に持っておく必要があります. これを添え字にもつDPを考えるとよいです. また, $K$個以内については, 最小で何個を考えてやって, 最後にそれが$K$個以下かを判定すればよいです.\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) \u003c (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate\u003cclass T\u003e\nstatic inline std::vector\u003cT\u003e ndvec(size_t\u0026\u0026 n, T val) noexcept {\n  return std::vector\u003cT\u003e(n, std::forward\u003cT\u003e(val));\n}\n\ntemplate\u003cclass... Tail\u003e\nstatic inline auto ndvec(size_t\u0026\u0026 n, Tail\u0026\u0026... tail) noexcept {\n  return std::vector\u003cdecltype(ndvec(std::forward\u003cTail\u003e(tail)...))\u003e(n, ndvec(std::forward\u003cTail\u003e(tail)...));\n}\n\nint main() {\n  i64 A, N;\n  cin \u003e\u003e A \u003e\u003e N;\n  i64 K;\n  cin \u003e\u003e K;\n  vector\u003ci64\u003e W(N);\n  rep(i,0,N) {\n    cin \u003e\u003e W[i];\n  }\n\n  vector\u003cvector\u003ci64\u003e\u003e dp(N + 1, vector\u003ci64\u003e(A + 1, 1e18));\n  dp[0][0] = 0;\n  rep(i,0,N) {\n    rep(j, 0, A + 1) {\n      if(j \u003e= W[i]) {\n        dp[i + 1][j] = std::min(dp[i][j], dp[i][j - W[i]] + 1);\n      }\n      else {\n        dp[i + 1][j] = dp[i][j];\n      }\n    }\n  }\n  if(dp[N][A] \u003c= K) {\n    cout \u003c\u003c \"YES\" \u003c\u003c endl;\n  }\n  else {\n    cout \u003c\u003c \"NO\" \u003c\u003c endl;\n  }\n}\n```\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/query_sqrt_decomposition_rsq":{"title":"RSQをクエリ平方分割で解いた時のメモ","content":"\nバケットサイズなんもわからん. 誰か助けて\n\n## クエリ平方分割\n\n[Point Add Range Sum - Library Checker](https://judge.yosupo.jp/problem/point_add_range_sum)をクエリ平方分割で解きます.  \nクエリ平方分割はその名の通り, クエリを分割しておいて, 各分割されたクエリで必要部分だけを残してほかは圧縮しておくことで, 高速に計算することができるテクです\n\nRange Compositeに対応するなら, $\\mathtt{update}$クエリだけはこんな感じに, 1点にしておく必要があります.\n\n![](/images/QuerySqrt/image1.png)\n\nただし, 今回はRange Sumなので, $\\mathtt{update}$クエリを無視して大丈夫です.\n\n![](/images/QuerySqrt/image2.png)\n\n## コード\n\nRange Compositeバージョン(Range Compositeを解いたとは言ってない)\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) \u003c (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nint main() {\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n  int N, Q;\n  cin \u003e\u003e N \u003e\u003e Q;\n  vector\u003ci64\u003e A(N + 1);\n  rep(i,0,N) {\n    cin \u003e\u003e A[i];\n  }\n  vector\u003cstd::tuple\u003cint, int, int\u003e\u003e B(Q);\n  rep(i,0,B.size()) {\n    int a, b, c;\n    cin \u003e\u003e a \u003e\u003e b \u003e\u003e c;\n    B[i] = { a, b, c };\n  }\n\n  const int Qsq = 2048;\n  const int Qsh = 11;\n  int Qsz = (Q + Qsq - 1) / Qsq;\n  std::bitset\u003c505050\u003e s;\n  std::bitset\u003c505050\u003e t;\n  vector\u003ci64\u003e idx(N + 1, 0);\n  vector\u003ci64\u003e Comp(Qsq * 2, 0);\n  for(int qi = 0; qi \u003c Qsz; qi++) {\n    int start = qi \u003c\u003c Qsh;\n    int end = std::min(Q, (qi + 1) \u003c\u003c Qsh);\n    s = 0;\n    t = 0;\n    for(int i = start; i \u003c end; i++) {\n      int a, b, c;\n      std::tie(a, b, c) = B[i];\n      if(a == 0) {\n        s.set(b);\n        t.set(b);\n      }\n      else {\n        s.set(b);\n        s.set(c);\n      }\n    }\n    Comp.assign(Qsq * 2, 0);\n    Comp[0] += A[0];\n    for(int i = 1;i \u003c N + 1;i++) {\n      idx[i] = idx[i - 1];\n      if(t[i - 1] || s[i]) {\n        idx[i]++;\n      }\n      Comp[idx[i]] += A[i];\n    }\n\n    for(int i = start; i \u003c end; i++) {\n      int a, b, c;\n      std::tie(a, b, c) = B[i];\n      if(a == 0) {\n        A[b] += c;\n        Comp[idx[b]] += c;\n      }\n      else {\n        i64 sum = 0;\n        for(int j = idx[b]; j \u003c idx[c]; j++) {\n          sum += Comp[j];\n        }\n        cout \u003c\u003c sum \u003c\u003c \"\\n\";\n      }\n    }\n  }\n}\n```\n\n[提出ページ](https://judge.yosupo.jp/submission/7486)\n\nRange Sumバージョン\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) \u003c (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nint main() {\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n  int N, Q;\n  cin \u003e\u003e N \u003e\u003e Q;\n  vector\u003ci64\u003e A(N + 1);\n  rep(i,0,N) {\n    cin \u003e\u003e A[i];\n  }\n  vector\u003cstd::tuple\u003cint, int, int\u003e\u003e B(Q);\n  rep(i,0,B.size()) {\n    int a, b, c;\n    cin \u003e\u003e a \u003e\u003e b \u003e\u003e c;\n    B[i] = { a, b, c };\n  }\n\n  int Qsq = 2048;\n  int Qsh = 11;\n  int Qsz = (Q + Qsq - 1) / Qsq;\n  std::bitset\u003c505050\u003e s;\n  vector\u003ci64\u003e idx(N + 1, 0);\n  vector\u003ci64\u003e Comp(4096, 0);\n  for(int qi = 0; qi \u003c Qsz; qi++) {\n    int start = qi \u003c\u003c Qsh;\n    int end = std::min(Q, (qi + 1) \u003c\u003c Qsh);\n    s = 0;\n    for(int i = start; i \u003c end; i++) {\n      int a, b, c;\n      std::tie(a, b, c) = B[i];\n      if(a == 1) {\n        s.set(b);\n        s.set(c);\n      }\n    }\n    Comp.assign(4096, 0);\n    Comp[0] += A[0];\n    for(int i = 1;i \u003c N + 1;i++) {\n      idx[i] = idx[i - 1];\n      if(s[i]) {\n        idx[i]++;\n      }\n      Comp[idx[i]] += A[i];\n    }\n\n    for(int i = start; i \u003c end; i++) {\n      int a, b, c;\n      std::tie(a, b, c) = B[i];\n      if(a == 0) {\n        A[b] += c;\n        Comp[idx[b]] += c;\n      }\n      else {\n        i64 sum = 0;\n        for(int j = idx[b]; j \u003c idx[c]; j++) {\n          sum += Comp[j];\n        }\n        cout \u003c\u003c sum \u003c\u003c \"\\n\";\n      }\n    }\n  }\n}\n```\n\n## Range Sum バケットサイズ(本編)\n\nこれをメモするためだけに記事を書いたと言っても過言ではない\n\n$N, Q \u003c= 500,000$でバケットサイズを変えた時の速度検証\n\n|バケットサイズ|速度|提出ページ|\n|:-|:-|:-|\n|256|1880ms|[7470](https://judge.yosupo.jp/submission/7470)|\n|512|1000ms|[7476](https://judge.yosupo.jp/submission/7476)|\n|1024|627ms|[7477](https://judge.yosupo.jp/submission/7477)|\n|2048|489ms|[7479](https://judge.yosupo.jp/submission/7479)|\n|4096|500ms|[7480](https://judge.yosupo.jp/submission/7480)|\n|8192|615ms|[7492](https://judge.yosupo.jp/submission/7492)|\n\nへ〜(空気)\n\nloop unrollとかすると早くなりました.\n\n## 〆\n\nバケットサイズなんもわからん\n","lastmodified":"2022-12-31T12:11:22.732628121Z","tags":null},"/notes/tarjans_offline_lca":{"title":"Tarjan's off-line LCA の実装メモと速度","content":"\nTarjan's off-line LCAを書いてみたので, その時のメモです.\n\n**ネタバレ注意**\n\n[No.898 tri-βutree - yukicoder](https://yukicoder.me/problems/no/898) のちょっとしたネタバレが含まれます...\n\n\u003cbr\u003e\n\nTarjan's off-line LCA(lowest common ancestors)は, LCAをoff-lineで$O((N + Q) \\alpha (N))$で求めるアルゴリズムです. ($\\alpha$は逆アッカーマン関数)\n\n[Tarjan's off-line lowest common ancestors algorithm - Wikipedia](https://en.wikipedia.org/wiki/Tarjan%27s_off-line_lowest_common_ancestors_algorithm)\n\nDFSの帰りがけに, `Union Find`で木の辺を`unite`していく. すると, `Union Find`で表現している集合は, いまたどっている頂点とのLCAが同じになる頂点の集合になります.\n\n![](/images/tarjans_uf_tree.png)\n\n具体例はこんな感じ. いま頂点$6$を見ているとします. 二重線はまだつなげていない辺です.\n\n緑の集合は, 頂点$6$とのLCAが頂点$0$である集合です. また, 青の集合は, 頂点$6$とのLCAが頂点$4$である集合です.  \nDFSの戻りってこういうことできるんだなあ\n\n## 実装\n\n注意点はクエリを処理するタイミングで, LCAを求めたい頂点２つのどちらもがdfsされた時であること(なので`ans == -2`を挟んでいる)\n\n```cpp\n#include \u003cvector\u003e\n#include \u003ciostream\u003e\n#include \u003cset\u003e\nusing namespace std;\n\nstruct union_find {\n  vector\u003cint\u003e par;\n  vector\u003cint\u003e rank;\n  union_find(int n) : par(n) , rank(n) {\n    for(int i = 0;i \u003c n;i++) par[i] = i;\n  }\n  int root(int i) {\n    return par[i] == i ? i : par[i] = root(par[i]);\n  }\n  /* unite x, y return parent */\n  int unite(int x,int y) {\n    x = root(x);\n    y = root(y);\n    if(x == y) return -1;\n    if(rank[x] \u003c rank[y]) {\n      par[x] = y;\n      return y;\n    }\n    else {\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++;\n      return x;\n    }\n  }\n};\n\nusing i64 = long long;\nstruct tarjans_offline_lca {\n  using E = pair\u003cint, i64\u003e;\n  vector\u003cvector\u003cE\u003e\u003e G;\n  vector\u003cint\u003e ance;\n  union_find uf;\n  vector\u003ci64\u003e weight;\n  vector\u003cpair\u003cint, int\u003e\u003e query;\n  vector\u003cvector\u003cpair\u003cint, int\u003e\u003e\u003e q;\n  vector\u003cint\u003e ans;\n  tarjans_offline_lca(int n): G(n), ance(n), uf(n), weight(n), q(n) {}\n\n  void add_edge(int a, int b, i64 w) {\n    G[a].push_back({ b, w });\n    G[b].push_back({ a, w });\n  }\n  void add_query(int a, int b) {\n    int i = query.size();\n    query.push_back({ a, b });\n    q[a].push_back({ b, i });\n    q[b].push_back({ a, i });\n  }\n  void dfs(int v, int f, i64 W) {\n    ance[v] = v;\n    weight[v] = W;\n    for(auto e: G[v]) {\n      int u = e.first;\n      i64 w = e.second;\n      if(f == u) continue;\n      dfs(u, v, w + W);\n      uf.unite(u, v);\n      ance[uf.root(v)] = v;\n    }\n    for(auto e: q[v]) {\n      int u = e.first;\n      int i = e.second;\n      if(ans[i] == -1) ans[i] = -2;\n      else if(ans[i] == -2) ans[i] = ance[uf.root(u)];\n    }\n  }\n  void offline_lca(int root) {\n    ans.assign(query.size(), -1);\n    dfs(root, -1, 0);\n  }\n};\n```\n\n使用例です. $N = 10^5$, LCAのクエリ数$Q = 3 * 10^5$で196msならいいんじゃない？ [#426438 No.898 tri-βutree - yukicoder](https://yukicoder.me/submissions/426438)\n\n## HLDが速いんじゃ\n\nHLDなんでこんなに速いんですかね. $O(N + Q \\log N)$のはずなんですが... 100ms [#426441 No.898 tri-βutree - yukicoder](https://yukicoder.me/submissions/426441)\n\n## しめ\n\nクエリを二回見てるのがダメなんですかね... LCAやるときはHLDでいいでしょう...  \nでも, DFS帰りがけがかなり面白い. どこかで使えるといいな\n","lastmodified":"2022-12-31T12:11:22.736628144Z","tags":null}}