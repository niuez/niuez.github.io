<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on</title><link>https://niuez.github.io/tags/Algorithm/</link><description>Recent content in Algorithm on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 19 Apr 2022 12:00:00 +0900</lastBuildDate><atom:link href="https://niuez.github.io/tags/Algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>倍数ゼータ・メビウス変換のメモ</title><link>https://niuez.github.io/notes/multiple_transform/</link><pubDate>Tue, 19 Apr 2022 12:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/multiple_transform/</guid><description>約数ゼータ・メビウス変換に続いて、倍数もメモします。
倍数ゼータ・メビウス変換 関数$f(n)$に対する倍数ゼータ変換は以下の定義です。$n | m$は「$m$は$n$の倍数」という意味で、$m$はmultipleのmです。
$$ F(n) = \sum_{ n | m } f(m) $$
倍数ゼータ変換の逆操作が倍数メビウス変換です。
倍数ゼータ・メビウス変換の実装 高速ゼータ変換の約数版 O(N log(log(N))) - noshi91のメモを参考にすると早い実装が得られます。</description></item><item><title>約数ゼータ・メビウス変換のメモ</title><link>https://niuez.github.io/notes/divisor_transform2/</link><pubDate>Mon, 18 Apr 2022 19:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/divisor_transform2/</guid><description>以前僕が書いた記事を復習するときにとても読みにくかったので、もう一度書き直します。
倍数ゼータ・メビウス変換についても書いたので、合わせて読むといいかも。同じ問題を別視点で考えてます。
約数ゼータ・メビウス変換 関数$f(n)$に対する約数ゼータ変換は以下の定義です。$d|n$は「$d$は$n$の約数」という意味です(dはdivisorのd)。約数の足し合わせですね。
$$ F(n) = \sum_{ d | n } f(d) $$
約数メビウス変換は、約数ゼータ変換の逆向きの操作です。つまり、$F(n)$から$f(n)$を求める操作です。
ちなみに、メビウス変換はメビウスの反転公式から メビウス関数を$\mu(n)$とすれば、
$$ f(n) = \sum_{d | n} F(d) \mu(\frac{n}{d}) $$</description></item><item><title>FPSのニュートン法メモ</title><link>https://niuez.github.io/notes/fps-newton/</link><pubDate>Thu, 14 Apr 2022 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/fps-newton/</guid><description>FPSのライブラリ書き直しに合わせて、 ABC222 H - Beautiful Binary Treeのニュートン法解(TLE)でニュートン法の勉強をしてみました. nyaanさんのライブラリに仕組みが書いてあるのでこれを読みました
$$ G(\hat{g}) \equiv f \pmod{x^n} \\ g \equiv \hat{g} - \frac{G(\hat{g}) - f}{G&amp;rsquo;(\hat{g})} \pmod{x^{2n}} $$</description></item><item><title>Library Checker - Associative Array に関するいろいろ</title><link>https://niuez.github.io/notes/lc_associative_array/</link><pubDate>Fri, 12 Jun 2020 23:02:44 +0900</pubDate><guid>https://niuez.github.io/notes/lc_associative_array/</guid><description>[Library Checker - Associative Array]を解くに当たってのいろいろをまとめておきます.
概要 Associative Arrayは, Mapとよく呼ばれるデータ構造です. キーとそれに対応する値の組を保持し, キーで検索して値を参照することができます.
Associative Arrayを実現するデータ構造は,
Map型の平衡二分探索木(ただし, キーが比較可能であることが条件) std::map 自作 HashMap std::unordered_map 自作(メインテーマ) std::map: 523ms Submit Info #12076</description></item><item><title>グラフ, 格子状のグラフ, 次元拡張グラフを同じコードで扱う抽象化BFS, DijkstraのC++14実装</title><link>https://niuez.github.io/notes/impl_abstract_dijkstra/</link><pubDate>Mon, 27 Apr 2020 01:08:48 +0900</pubDate><guid>https://niuez.github.io/notes/impl_abstract_dijkstra/</guid><description>これすごく悩んでいたんですけど, 新しい実装法を考えたらスッキリしたのでまとめます.
先駆者がいたらごめん, 勝手ににう式グラフ抽象化って言っちゃおうかな
意思 DijkstraやBFSのライブラリを書いておきたい！
問題点 同じアルゴリズムのライブラリを, 種類の違うグラフに対して一つずつ書くのは本当にイヤ 格子状のグラフをわざわざ, std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; Gに構築するのは定数倍があるのでイヤ. 問題を解くために次元拡張したグラフをわざわざ構築するのは, キレイじゃない struct edgeがC++においてはなんかイヤ, 隣接する頂点がint toで固定しないとダメだったりでイヤ(Rustのtraitとかあるならまだしも 個人差あり) そもそもstruct edgeを毎回書くのもイヤ(競プロなので) 隣接リストを毎回std::vector&amp;lt;edge&amp;gt;で返すのもキレイじゃない, できるだけ無駄はなくしたい.</description></item><item><title>RSQをクエリ平方分割で解いた時のメモ</title><link>https://niuez.github.io/notes/query_sqrt_decomposition_rsq/</link><pubDate>Fri, 17 Apr 2020 10:19:21 +0900</pubDate><guid>https://niuez.github.io/notes/query_sqrt_decomposition_rsq/</guid><description>バケットサイズなんもわからん. 誰か助けて
クエリ平方分割 Point Add Range Sum - Library Checkerをクエリ平方分割で解きます.
クエリ平方分割はその名の通り, クエリを分割しておいて, 各分割されたクエリで必要部分だけを残してほかは圧縮しておくことで, 高速に計算することができるテクです
Range Compositeに対応するなら, $\mathtt{update}$クエリだけはこんな感じに, 1点にしておく必要があります.
ただし, 今回はRange Sumなので, $\mathtt{update}$クエリを無視して大丈夫です.</description></item><item><title>Fully Retroactive Stack 実装してみた</title><link>https://niuez.github.io/notes/fully_retroactive_stack/</link><pubDate>Fri, 10 Apr 2020 20:09:09 +0900</pubDate><guid>https://niuez.github.io/notes/fully_retroactive_stack/</guid><description>noshi91さんがFully Retroactive Stackについての解説生放送をやっていたので, その解説通りに実装してみました. ちょっとした解説も書きました.
できること Stackの処理できるクエリは以下の通りです.
$\mathtt{push}(x)$: 要素 $x$ を列の後ろに追加する. $\mathtt{pop}()$: 列の一番後ろの要素を取り出す. $\mathtt{top}()$: 列の後ろの要素を求める. これをFully Retroactive Stackに進化させると, こんな感じ.</description></item><item><title>DFS+BFS Numberingで部分木の任意深さのクエリを処理する</title><link>https://niuez.github.io/notes/dfs_bfs_et/</link><pubDate>Tue, 24 Mar 2020 18:05:05 +0900</pubDate><guid>https://niuez.github.io/notes/dfs_bfs_et/</guid><description>Tree Depth Query by BFS Numberingについては Tree Depth Query by BFS Numbering - niuez.github.ioを参照してください.
処理したいクエリ (例) 有向木が与えられ, 各頂点には重みがある.
頂点$v$から, 辺をちょうど$d$個たどって到達できる頂点の重みの総和を出力 総和じゃなくても更新とかもしたいよね.</description></item><item><title>Tarjan's off-line LCA の実装メモと速度</title><link>https://niuez.github.io/notes/tarjans_offline_lca/</link><pubDate>Wed, 05 Feb 2020 20:33:01 +0900</pubDate><guid>https://niuez.github.io/notes/tarjans_offline_lca/</guid><description>Tarjan&amp;rsquo;s off-line LCAを書いてみたので, その時のメモです.
ネタバレ注意
No.898 tri-βutree - yukicoder のちょっとしたネタバレが含まれます&amp;hellip;
Tarjan&amp;rsquo;s off-line LCA(lowest common ancestors)は, LCAをoff-lineで$O((N + Q) \alpha (N))$で求めるアルゴリズムです.</description></item><item><title>約数畳み込みを使って最大公約数と集合をうまく扱うメモ</title><link>https://niuez.github.io/notes/divisor_transform_memo/</link><pubDate>Mon, 03 Feb 2020 21:20:02 +0900</pubDate><guid>https://niuez.github.io/notes/divisor_transform_memo/</guid><description>とっても読みにくいので新しいのをよんで！！ あたらしいの
ふるいの↓ 移植テストです
書いて置かないと頭に置いておけない気がしたのでメモを残す. 間違ってたらごめん
これについて気になったので
メビウス関数とかを導入するとより形式的に約数とかを扱えるようになるのかなあ
&amp;mdash; Niuez (@xiuez) January 22, 2020 概要 約数畳み込み メビウス関数 メビウスの反転公式(約数畳み込みの逆操作) 約数畳み込みと逆約数畳み込みのアルゴリズム $O(A \log{\log A})$ 最大公約数の扱い 集合の扱い AGC038C LCMsの解き方 ネタバレあるので気をつけてください</description></item><item><title>Suffix Array と LCP と 文字列検索の実装をした</title><link>https://niuez.github.io/notes/entry/2019/12/16/203739/</link><pubDate>Mon, 16 Dec 2019 20:37:39 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/12/16/203739/</guid><description>この土日のメモです. SAとLCPのお気持ちをまとめたくなっただけ. 間違ってたらごめん
文字列アルゴの勉強する気が起きないたった一つの理由: Rolling Hash— νιυεζ (@xiuez) 2019年12月13日
これをやめたいので, 手始めにSuffix Arrayを使った文字列検索をやってみようかなというのが今回の主題
概要 SA-ISでSuffix Arrayを構築$ O(|S|)$ LCP配列の構築$ O(|S|)$ LCPによるSuffix同士のLCPをSparse Tableで構築$ O(|S| \log{|S|})$, クエリ$ O(1)$ Suffix Arrayの二分探索で文字列検索を$ O(|T| log{|S|})$ Suffix ArrayとLCPの二分探索で文字列検索を構築$ O(|S|)$, クエリ$ O(|T| + \log{|S|})$ の実装をやってみました.</description></item><item><title>動的木上の最小シュタイナー木をtoptreeで解く</title><link>https://niuez.github.io/notes/entry/2019/12/14/000036/</link><pubDate>Sat, 14 Dec 2019 00:00:36 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/12/14/000036/</guid><description>この記事は「データ構造とアルゴリズム Advent Calendar 2019」 14日目の記事です. 13日目は@ajalabさんのRun-Length FM-Index - koki, 15日目は@minaminaoさんのMerkle Patricia Tree まわりです.
toptreeとは toptreeは今年競プロ界隈で話題になった動的木を扱うデータ構造の一つです. link-cut treeも同じ動的木を扱うデータ構造ですが, 機能だけを見ればその完全上位互換です.
toptreeは, 木を動的に扱うデータ構造です. [cs/0310065] Maintaining Information in Fully-Dynamic Trees with Top Treesを読みました.</description></item><item><title>BFS Numbering</title><link>https://niuez.github.io/notes/entry/2019/10/05/002503/</link><pubDate>Sat, 05 Oct 2019 00:25:03 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/10/05/002503/</guid><description>僕が木上クエリコンで出題した問題で使った手法です.
No.899 γatheree - yukicoder
アルゴリズム 例
BFSを行って頂点に番号を順番に振っていきます.
1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 になります.</description></item><item><title>Toptree - Link &amp; Cut編</title><link>https://niuez.github.io/notes/entry/2019/08/05/114511/</link><pubDate>Mon, 05 Aug 2019 11:45:11 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/08/05/114511/</guid><description>Toptree 導入編 - niuez’s diary
引き続き, toptreeの解説をしていきます.
Link link(v, w): 頂点vとwを辺vwで結ぶをします.
場合分けが多すぎるんじゃ
が, vの次数が0, 1, 2以上で処理が変わり, またwの次数が0, 1, 2以上で処理が変わります. (ちなみに論文はどちらも次数2以上のときのことしか書いてない, 全部書けや)</description></item><item><title>Toptree 導入編</title><link>https://niuez.github.io/notes/entry/2019/08/04/191420/</link><pubDate>Sun, 04 Aug 2019 19:14:20 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/08/04/191420/</guid><description>みんな日本語記事を待っていたはず&amp;hellip;.!
toptreeがどんな感じで動いているのかを書いてみます
実装はここにあります
https://github.com/niuez/toptree-rust
0. toptree is なに toptreeはlink-cut treeの上位互換です. 木を切ったりつなげたり, パスのクエリを処理したり, 木上の二分探索ができたりします
今回はそのベースとなる構造の話です
1. Compress Rake 木をまとめる ここで言う木は, toptreeが表す木のことです. 曖昧にならないようにこのことをreal treeと呼ぶことにします.</description></item><item><title>top-tree実装体験木</title><link>https://niuez.github.io/notes/entry/2019/06/29/161729/</link><pubDate>Sat, 29 Jun 2019 16:17:29 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/06/29/161729/</guid><description>読者層が限定されすぎていませんか？
Link Cut Treeを書いたことがない人はこちら！
Link-Cut 木 - ei1333の日記
部分木クエリについてはこちら！
Link Cut Treeで部分木の情報を管理する - beet's soil
最遠点クエリについてはこちら！
Link-Cut木と最遠点クエリ - ei1333の日記</description></item><item><title>ダイクストラとポテンシャルのはなし</title><link>https://niuez.github.io/notes/entry/2019/03/04/142903/</link><pubDate>Mon, 04 Mar 2019 14:29:03 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/03/04/142903/</guid><description>はじめまして, niuezといいます. 競プロを少ししています.
最近勉強したことのメモ書きをしておきます.
ダイクストラ法 ダイクストラ法(Dijkstra)は負の長さの無いグラフで始点からの最短距離を求めるアルゴリズムです.
具体的には
距離が未確定の頂点の中で一番小さいものを選び, 距離を確定させる. 選んだ頂点から距離が未確定の頂点に伸びる辺で, 未確定な距離をより短いものに更新する. を繰り返します. これを実装すると $O(N)$ですが, よく知られるダイクストラの計算量は $O((E+ V) \log E)$ です(heapとかを使う).</description></item></channel></rss>