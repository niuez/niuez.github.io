<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on</title><link>https://niuez.github.io/notes/</link><description>Recent content in Notes on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 11 Jan 2023 15:00:00 +0900</lastBuildDate><atom:link href="https://niuez.github.io/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>ギャンブラー問題(強化学習第2版 4.4 価値反復)</title><link>https://niuez.github.io/notes/reinforcement_learning_ch4_4/</link><pubDate>Wed, 11 Jan 2023 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/reinforcement_learning_ch4_4/</guid><description>ギャンブラー問題 $p_h=0.4,0.25,0.55$それぞれのギャンブラー問題について、価値反復を用いて最適方策を求めた。
実装は、 reinforcement_learning/main.cpp at main - niuez/reinforcement_learningに載せてある。
価値関数と、最適方策を図にした。
$p_h=0.4$ $p_h=0.25$ $p_h \leq 0.5$では、どこかで賭けをして勝ちを狙いに行く必要があるっぽい。
$p_h=0.55$ $p_h=0.55$については、少しずつ掛けて勝つことができるのでこのような結果になった。</description></item><item><title>ブラックジャック問題(強化学習第2版 5 方策オン/オフ型)</title><link>https://niuez.github.io/notes/reinforcement_learning_ch5/</link><pubDate>Wed, 11 Jan 2023 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/reinforcement_learning_ch5/</guid><description>ブラックジャック問題 方策オン型初回訪問MCと、方策オフ型重み付き重点サンプリングMCを実装した。コードは reinforcement_learning/main.cpp at main · niuez/reinforcement_learningに載せてある。両方、ソフト方策はεソフトを用いている。収束は方策オフ型の方がはやかった。
両者の違いは後者が、グリーディーな方策と、εによって選ばれたランダムな方策による価値の更新の重みが異なることだ。前者は同一に扱っている。
1: ヒット(もう一枚) 0: スティック(やめ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ace = 0 A23456789T 11 : 1111111111 12 : 1110001111 13 : 1000001111 14 : 1000001111 15 : 1000001111 16 : 1000001111 17 : 0000000000 18 : 0000000000 19 : 0000000000 20 : 0000000000 21 : 0000000000 ace = 1 A23456789T 11 : 0000000000 12 : 1111111111 13 : 1111111111 14 : 1111111111 15 : 1111111111 16 : 1111111111 17 : 1111111111 18 : 1000000011 19 : 0000000000 20 : 0000000000 21 : 0000000000 価値関数について、ヒットするかスティックするかの差分を計算してみた。赤ほどヒットした方がよく、青ほどスティックした方がいい。</description></item><item><title>ジャックのレンタカー会社問題(強化学習第2版 4.3 方策反復)</title><link>https://niuez.github.io/notes/reinforcement_learning_ch4_3/</link><pubDate>Tue, 10 Jan 2023 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/reinforcement_learning_ch4_3/</guid><description>ジャックのレンタカー会社問題 ジャックのレンタカー会社問題について方策反復を用いて最適方策を求めた。本と同じ結果を得ることができた。
実装は、 reinforcement_learning/main.cpp at main - niuez/reinforcement_learningに載せてある。
練習問題4.7 上の拡張を行えば良い。$V(s)$についてプロットすると以下のようになった。
各状態における行動は以下のようになった。右向きに1つ目の支店の台数、下向きに2つ目の支店の台数、行動は「1つ目の支店の台数の変化」で表している。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 0 0 0 0 0 0 0 0 1 1 2 2 2 3 4 5 4 4 4 4 4 0 0 0 0 0 0 0 0 0 1 1 1 2 3 4 5 3 3 3 3 4 0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 2 2 2 2 3 3 0 0 0 0 0 0 0 0 0 0 0 1 2 3 1 1 1 1 2 2 2 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -2 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -3 -3 -2 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -4 -3 -3 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -4 -4 -3 -3 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -5 -4 -4 -3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 -5 -5 -4 -4 -3 -3 -2 -1 -1 -1 0 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 -5 -5 -5 -4 -4 -3 -2 -2 -2 0 0 -2 -2 -2 -2 -2 -2 -2 -2 0 0 -5 -5 -5 -5 -4 -3 -3 -3 0 0 0 1 0 0 0 0 0 0 0 0 0 -5 -5 -5 -5 -4 -4 -4 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -5 -5 -5 -5 -5 -5 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -5 -5 -5 -5 -5 -4 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -5 -5 -5 -5 -5 -4 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -5 -5 -5 -5 -5 -4 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -5 -5 -5 -5 -5 -4 -3 0 0 0 0 1 0 0 0 0 0 0 0 0 0 -5 -5 -5 -5 -5 -4 -3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 高速化について この実装だと、$\sum_{s&amp;rsquo;, r} p(s&amp;rsquo;, r | s, a) (r + \gamma V(s&amp;rsquo;))$の計算に、車の最大数を$N$として$O(N^4)$かかる。</description></item><item><title>k本腕バンディット問題(強化学習第2版 2章)</title><link>https://niuez.github.io/notes/reinforcement_learning_ch2/</link><pubDate>Mon, 09 Jan 2023 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/reinforcement_learning_ch2/</guid><description>強化学習第2版を買った 今まで焼きなまし法や遺伝的プログラミングによる、「最終的な結果に対する評価」によって最適化を行う手法を勉強してきたが、「一手一手に対する評価」はどのようにするのか興味が湧いたので勉強してみる。
k本腕バンディット問題に対するアプローチ ε-greedy法、楽観的初期値をもつε-greedy法、上限信頼区間(UCB)行動選択法、確率的勾配上昇法を実装して、得られた報酬の平均と最適行動の割合を各ステップについて計算しグラフにした。
実装は、 reinforcement_learning/main.cpp at main - niuez/reinforcement_learningに載せてある。</description></item><item><title>NSGA-IIによるMulti Knapsack Problemへのアプローチ</title><link>https://niuez.github.io/notes/nsgaii_multi_knapsack/</link><pubDate>Sat, 31 Dec 2022 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/nsgaii_multi_knapsack/</guid><description>概要 前回勉強したLexicase Selection入門の話では、多目的関数に対する最適化を行った。 今回は、同じく多目的関数に対する手法であるNon-dominated Sorting Genetic Algorithm II(NSGA-II)を勉強したのでメモしておく。
参考
A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II 多数目的最適化問題における進化型多目的最適化 アルゴリズムの問題点とその改良手法に関する考察 多目的最適化問題のNSGA-Ⅱを勉強したの整理しました - Qiita 多目的な最適化問題を解くためにNSGA-Ⅱを解説する - Qiita 参考2で示されているが、目的関数が増えるほどこのアルゴリズムが弱っていく。こういうときはlexicaseが有効になるらしい。(ICPCのコーチ曰く)</description></item><item><title>Genetic Algorithm + Lexicase SelectionによるBoolean CSPのアプローチ</title><link>https://niuez.github.io/notes/lexicase_booleanCSP/</link><pubDate>Thu, 29 Dec 2022 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/lexicase_booleanCSP/</guid><description>概要 多目的関数の場合に線形和を取るとパラメータ調整に時間がかかってしまう。特に、目的関数がとても多い場合はもっと難しくなる。ここでは、多目的関数Genetic AlgorithmのSelection(選択)で使えるLexicase Selectionの概要と、それを用いたBoolean CSPへのアプローチをメモしておく。
今回も、目的関数は小さくするのを目標とする。
参考: Lexicase Selection Beyond Genetic Programming, スライド版
Lexicase Selection Lexicase Selectionは以下のようなアルゴリズムである。
$I$を現在の世代の個体全ての集合とする。 目的関数をランダムにシャッフルした配列$f_i$を構成する $i = 1.</description></item><item><title>Genetic Local Search + MSXFの勉強とIntroduction to Heuristic Contest</title><link>https://niuez.github.io/notes/genetic_local_search_IHC/</link><pubDate>Sun, 11 Dec 2022 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/genetic_local_search_IHC/</guid><description>概要 遺伝的アルゴリズム(Genetic Algorithm)の練習として Introduction to Heuristic Contestの問題を解いてみました。最終的なスコアは117Mで焼きなましの124Mには劣りますが、良い成績は得られていそうです。
前回勉強したGenetic Algorithmの入門の話も参考に
方針 遺伝的局所探索法によるジョブショップスケジューリング問題の解法で述べられている
Genetic Local Search(遺伝的局所探索, GLS) Multi Step Crossover Fusion(多段階探索交叉, MSXF) の2つの手法を取り入れました。</description></item><item><title>Genetic Algorithmの勉強と巡回セールスマン問題</title><link>https://niuez.github.io/notes/genetic_local_search_tsp/</link><pubDate>Sat, 10 Dec 2022 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/genetic_local_search_tsp/</guid><description>Genetic Algorithm Genetic Algorithm(GA, 遺伝的アルゴリズム)は、問題に対する解を個体とし、選択・交叉・突然変異の操作によって個体の集合からなる世代を更新し、最適解を導くヒューリスティックアルゴリズムです。
AtCoderの巡回セールスマン問題のジャッジを通せたので、手法を書き残しておきます。 ジャッジ結果
染色体の定義 各個体には「染色体」と呼ばれる、解を持つ情報の列を持たせます。今回は訪れる頂点番号の順番をそのまま順列として保持しました。
交叉 Genetic Algorithm中では、二つの染色体を混ぜて新しい染色体を作り出す「交叉」という操作を行います。この操作では二つの解の特徴を残しながら繋ぐ必要があります。今回は順序交叉を用いました。
順序交叉は片方の親から一部の順列をそのまま引き継ぎ、残りの部分についてはもう一つの親での相対的な順序で補完するというものです。
1 2 3 4 5 6 p1 = (1 2 3 | 4 5 6 7 | 8 9) p2 = (4 5 2 | 1 8 7 6 | 9 3) p2&amp;#39;= (9 3 2 1 8) ch = (2 1 8 | 4 5 6 7 | 9 3) 突然変異 解が確率で新しい解を見つけるように、突然変異という操作を行います。今回は、確率で2点swapを行うことにしました。</description></item><item><title>倍数ゼータ・メビウス変換のメモ</title><link>https://niuez.github.io/notes/multiple_transform/</link><pubDate>Tue, 19 Apr 2022 12:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/multiple_transform/</guid><description>約数ゼータ・メビウス変換に続いて、倍数もメモします。
倍数ゼータ・メビウス変換 関数$f(n)$に対する倍数ゼータ変換は以下の定義です。$n | m$は「$m$は$n$の倍数」という意味で、$m$はmultipleのmです。
$$ F(n) = \sum_{ n | m } f(m) $$
倍数ゼータ変換の逆操作が倍数メビウス変換です。
倍数ゼータ・メビウス変換の実装 高速ゼータ変換の約数版 O(N log(log(N))) - noshi91のメモを参考にすると早い実装が得られます。</description></item><item><title>約数ゼータ・メビウス変換のメモ</title><link>https://niuez.github.io/notes/divisor_transform2/</link><pubDate>Mon, 18 Apr 2022 19:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/divisor_transform2/</guid><description>以前僕が書いた記事を復習するときにとても読みにくかったので、もう一度書き直します。
倍数ゼータ・メビウス変換についても書いたので、合わせて読むといいかも。同じ問題を別視点で考えてます。
約数ゼータ・メビウス変換 関数$f(n)$に対する約数ゼータ変換は以下の定義です。$d|n$は「$d$は$n$の約数」という意味です(dはdivisorのd)。約数の足し合わせですね。
$$ F(n) = \sum_{ d | n } f(d) $$
約数メビウス変換は、約数ゼータ変換の逆向きの操作です。つまり、$F(n)$から$f(n)$を求める操作です。
ちなみに、メビウス変換はメビウスの反転公式から メビウス関数を$\mu(n)$とすれば、
$$ f(n) = \sum_{d | n} F(d) \mu(\frac{n}{d}) $$</description></item><item><title>FPSのニュートン法メモ</title><link>https://niuez.github.io/notes/fps-newton/</link><pubDate>Thu, 14 Apr 2022 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/fps-newton/</guid><description>FPSのライブラリ書き直しに合わせて、 ABC222 H - Beautiful Binary Treeのニュートン法解(TLE)でニュートン法の勉強をしてみました. nyaanさんのライブラリに仕組みが書いてあるのでこれを読みました
$$ G(\hat{g}) \equiv f \pmod{x^n} \\ g \equiv \hat{g} - \frac{G(\hat{g}) - f}{G&amp;rsquo;(\hat{g})} \pmod{x^{2n}} $$</description></item><item><title>ARC028 D - 注文の多い高橋商店</title><link>https://niuez.github.io/notes/arc028-d/</link><pubDate>Wed, 13 Apr 2022 15:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/arc028-d/</guid><description>ARC028 D - 注文の多い高橋商店
まず、クエリを無視して計算をします。このときのFPSを$F$とおくと、
$$ \begin{aligned} F &amp;amp;= \prod_{i = 1}^{N} (1 + \cdots + x^{a_i}) \\ &amp;amp;= \prod_{i = 1}^{N} \frac{1 - x^{a_i + 1}}{1 - x} \\ &amp;amp;= (1 - x)^{-N} \prod_{i = 1}^{N} (1 - x^{a_i + 1}) \end{aligned} $$</description></item><item><title>ABC135 D - Digits Parade</title><link>https://niuez.github.io/notes/abc135-d/</link><pubDate>Wed, 13 Apr 2022 14:30:00 +0900</pubDate><guid>https://niuez.github.io/notes/abc135-d/</guid><description>ABC135 D - Digits Parade
最初に$S$を反転させておきます。
$$ f_{i} = \begin{cases} x^{10^i a} &amp;amp; (S_i=a) \\ \sum_{j=0}^{9} x^{10^i j} &amp;amp; (S_i=?</description></item><item><title>EDPC M - CandiesをFPSで</title><link>https://niuez.github.io/notes/edpc-m/</link><pubDate>Wed, 13 Apr 2022 14:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/edpc-m/</guid><description>EDPC M - Candies
$$ \begin{align} &amp;amp; \prod_{i = 1}^{N} (1 + x + \cdots + x^{a_i}) \\ &amp;amp; = \prod_{i = 1}^{N} \frac{1 - x^{a_i + 1}}{1 - x} \\ &amp;amp; = (1 - x)^{-N} \prod_{i = 1}^{N} (1 - x^{a_i + 1}) \end{align} $$</description></item><item><title>KUPC2019 K - One or AllをFPSで</title><link>https://niuez.github.io/notes/kupc2019-k/</link><pubDate>Wed, 13 Apr 2022 13:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/kupc2019-k/</guid><description>KUPC2019 K - One or All
$$ \begin{align} &amp;amp;(x + y + z + x^{-1} + y^{-1} + z^{-1} + xyz + (xyz)^{-1})^n \\ &amp;amp; = \frac{(1 + xy)^n (1 + xz)^n (1 + yz)^n}{x^n y^n z^n} \\ &amp;amp; = (xyz)^{-n} \sum_{i, j, k} \binom{n}{i} \binom{n}{j} \binom{n}{k} (xy)^i (xz)^j (yz)^k \\ &amp;amp; = (xyz)^{-n} \sum_{i, j, k} \binom{n}{i} \binom{n}{j} \binom{n}{k} x^{i+j} y^{i+k} z^{j+k} \\ \end{align} $$</description></item><item><title>ABC051 B Sum of Three IntegersをO(1)</title><link>https://niuez.github.io/notes/abc051-b/</link><pubDate>Tue, 12 Apr 2022 13:00:00 +0900</pubDate><guid>https://niuez.github.io/notes/abc051-b/</guid><description>今日 maspyさんの形式的べき級数の記事を読んだ後に、サークルの見学会にいったらいきなりバチャが始まって、FPSが使えたのでメモ
ABC051B 全探索で$O(K^2)$ですが、これを$O(1)$まで落としましょう。
まずは、問題をべき級数に落とし込むところからスタートしましょう。$[0, K]$から1つ整数を選ぶのは、$1+x+x^2+&amp;hellip;x^K$と表せて、3個選んで和をとるのは$(1+x+x^2+&amp;hellip;x^K)^3$となって、求めたい答えは$x^S$の係数となります。この式展開を愚直にすれば$O(K^2)$です。
式変形して計算量を改善していきます。等比数列の和から、$(1+x+x^2+&amp;hellip;x^K)^3 = \frac{(1 - x^{K + 1})^3}{(1 - x)^3}$となります。分子は展開して$1 - 3 x^{K + 1} + 3 x^{2 (K + 1)} - x^{3(K + 1)}$となります.</description></item><item><title>ブロウちゃんをデスクトップにわいわいさせる(moviepy, ffmpeg, Übersicht)</title><link>https://niuez.github.io/notes/buro_ubersicht/</link><pubDate>Tue, 29 Dec 2020 21:20:02 +0900</pubDate><guid>https://niuez.github.io/notes/buro_ubersicht/</guid><description>弊高専アドカレ埋めます
背景 SteamのセールでMuse Dash買いました. ブロウちゃん(アイドル)かわいすぎるなということで, ブロウちゃんをデスクトップでいつでも見れるようにしよう, という企画です.
元素材はキャラ選択画面だとUIが被って見切れるのでYoutubeから拾ってきた.
透過 moviepyでframeに分割していい感じにフィルタ処理, アルファチャンネルを追加してpngに叩き込む.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from moviepy.</description></item><item><title>Hugoのテーマを変えました &amp; lyla colorschemeについて</title><link>https://niuez.github.io/notes/lyla_theme/</link><pubDate>Fri, 24 Jul 2020 00:04:58 +0900</pubDate><guid>https://niuez.github.io/notes/lyla_theme/</guid><description>.pallet h2 { border-bottom: initial; } Hugoテーマ変えました ま〜〜〜たテーマとか色とかいじくってた. 定期的にくる, この抑えられない衝動.
白はディスプレイにおいてはかなりの強調色なので, それが背景色とはどういうことやねんとは思っていたので, 思い切って自分が使っているカラースキームをHugoにも導入してやろうと思った感じです.
カラースキームについて niuez/lyla.vimで公開しています
#242828 背景色 #6A6868 グレー ボーダー線を引いたり #A4A4A4 文章の色 でもあまり強調しない感じ #737FC4 深い青 目立ってほしくないけどいてほしい単語に使う using, return とか #6F8EB3 ノーマルな青 Vimではこれを標準の文字の色にしている #82BFF5 明るい青 ハイライトしたいものに使う 検索結果のハイライトとか #D06E3E 深い橙 目立ってほしい単語に使う const, if, while, forとか, #BD8840 ノーマルな橙 目立って欲しさNo.</description></item><item><title>Library Checker - Associative Array に関するいろいろ</title><link>https://niuez.github.io/notes/lc_associative_array/</link><pubDate>Fri, 12 Jun 2020 23:02:44 +0900</pubDate><guid>https://niuez.github.io/notes/lc_associative_array/</guid><description>[Library Checker - Associative Array]を解くに当たってのいろいろをまとめておきます.
概要 Associative Arrayは, Mapとよく呼ばれるデータ構造です. キーとそれに対応する値の組を保持し, キーで検索して値を参照することができます.
Associative Arrayを実現するデータ構造は,
Map型の平衡二分探索木(ただし, キーが比較可能であることが条件) std::map 自作 HashMap std::unordered_map 自作(メインテーマ) std::map: 523ms Submit Info #12076</description></item><item><title>グラフ, 格子状のグラフ, 次元拡張グラフを同じコードで扱う抽象化BFS, DijkstraのC++14実装</title><link>https://niuez.github.io/notes/impl_abstract_dijkstra/</link><pubDate>Mon, 27 Apr 2020 01:08:48 +0900</pubDate><guid>https://niuez.github.io/notes/impl_abstract_dijkstra/</guid><description>これすごく悩んでいたんですけど, 新しい実装法を考えたらスッキリしたのでまとめます.
先駆者がいたらごめん, 勝手ににう式グラフ抽象化って言っちゃおうかな
意思 DijkstraやBFSのライブラリを書いておきたい！
問題点 同じアルゴリズムのライブラリを, 種類の違うグラフに対して一つずつ書くのは本当にイヤ 格子状のグラフをわざわざ, std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; Gに構築するのは定数倍があるのでイヤ. 問題を解くために次元拡張したグラフをわざわざ構築するのは, キレイじゃない struct edgeがC++においてはなんかイヤ, 隣接する頂点がint toで固定しないとダメだったりでイヤ(Rustのtraitとかあるならまだしも 個人差あり) そもそもstruct edgeを毎回書くのもイヤ(競プロなので) 隣接リストを毎回std::vector&amp;lt;edge&amp;gt;で返すのもキレイじゃない, できるだけ無駄はなくしたい.</description></item><item><title>RSQをクエリ平方分割で解いた時のメモ</title><link>https://niuez.github.io/notes/query_sqrt_decomposition_rsq/</link><pubDate>Fri, 17 Apr 2020 10:19:21 +0900</pubDate><guid>https://niuez.github.io/notes/query_sqrt_decomposition_rsq/</guid><description>バケットサイズなんもわからん. 誰か助けて
クエリ平方分割 Point Add Range Sum - Library Checkerをクエリ平方分割で解きます.
クエリ平方分割はその名の通り, クエリを分割しておいて, 各分割されたクエリで必要部分だけを残してほかは圧縮しておくことで, 高速に計算することができるテクです
Range Compositeに対応するなら, $\mathtt{update}$クエリだけはこんな感じに, 1点にしておく必要があります.
ただし, 今回はRange Sumなので, $\mathtt{update}$クエリを無視して大丈夫です.</description></item><item><title>Fully Retroactive Stack 実装してみた</title><link>https://niuez.github.io/notes/fully_retroactive_stack/</link><pubDate>Fri, 10 Apr 2020 20:09:09 +0900</pubDate><guid>https://niuez.github.io/notes/fully_retroactive_stack/</guid><description>noshi91さんがFully Retroactive Stackについての解説生放送をやっていたので, その解説通りに実装してみました. ちょっとした解説も書きました.
できること Stackの処理できるクエリは以下の通りです.
$\mathtt{push}(x)$: 要素 $x$ を列の後ろに追加する. $\mathtt{pop}()$: 列の一番後ろの要素を取り出す. $\mathtt{top}()$: 列の後ろの要素を求める. これをFully Retroactive Stackに進化させると, こんな感じ.</description></item><item><title>DFS+BFS Numberingで部分木の任意深さのクエリを処理する</title><link>https://niuez.github.io/notes/dfs_bfs_et/</link><pubDate>Tue, 24 Mar 2020 18:05:05 +0900</pubDate><guid>https://niuez.github.io/notes/dfs_bfs_et/</guid><description>Tree Depth Query by BFS Numberingについては Tree Depth Query by BFS Numbering - niuez.github.ioを参照してください.
処理したいクエリ (例) 有向木が与えられ, 各頂点には重みがある.
頂点$v$から, 辺をちょうど$d$個たどって到達できる頂点の重みの総和を出力 総和じゃなくても更新とかもしたいよね.</description></item><item><title>OyamaC'20 解説</title><link>https://niuez.github.io/notes/oyamac20/</link><pubDate>Thu, 19 Mar 2020 20:10:48 +0900</pubDate><guid>https://niuez.github.io/notes/oyamac20/</guid><description>小山高専で, mitsuさん原案のコンテスト OyamaCが行われました. testerを担当したので, 解説を書いておきます.
fizzbuzz fizzbuzzは書けますか？N % 15から書くとスムーズです.
1 2 3 4 5 6 7 8 9 10 11 #include &amp;lt;bits/stdc++.</description></item><item><title>ABC155 F Perils in ParallelをF_2の行列で解く</title><link>https://niuez.github.io/notes/abc155-f/</link><pubDate>Sat, 22 Feb 2020 16:40:51 +0900</pubDate><guid>https://niuez.github.io/notes/abc155-f/</guid><description>ABC155-F Perils in Parallel - kotatsugameの日記を読んだときのメモです.
AtCoder F - Perils in Parallelを$\mathbb{F}_2$上の行列として考えて解きます. 以下この問題のネタバレを含みます
問題を簡単にする 座標$i \ (0 \le i \le N)$のスイッチの状態が$B_i$ $i \ (0 \le i \le M)$のコードは$[L_i, R_i) \ (0 \le L_i, R_i \le N)$の範囲のスイッチのオンオフを切り替える.</description></item><item><title>Tarjan's off-line LCA の実装メモと速度</title><link>https://niuez.github.io/notes/tarjans_offline_lca/</link><pubDate>Wed, 05 Feb 2020 20:33:01 +0900</pubDate><guid>https://niuez.github.io/notes/tarjans_offline_lca/</guid><description>Tarjan&amp;rsquo;s off-line LCAを書いてみたので, その時のメモです.
ネタバレ注意
No.898 tri-βutree - yukicoder のちょっとしたネタバレが含まれます&amp;hellip;
Tarjan&amp;rsquo;s off-line LCA(lowest common ancestors)は, LCAをoff-lineで$O((N + Q) \alpha (N))$で求めるアルゴリズムです.</description></item><item><title>約数畳み込みを使って最大公約数と集合をうまく扱うメモ</title><link>https://niuez.github.io/notes/divisor_transform_memo/</link><pubDate>Mon, 03 Feb 2020 21:20:02 +0900</pubDate><guid>https://niuez.github.io/notes/divisor_transform_memo/</guid><description>とっても読みにくいので新しいのをよんで！！ あたらしいの
ふるいの↓ 移植テストです
書いて置かないと頭に置いておけない気がしたのでメモを残す. 間違ってたらごめん
これについて気になったので
メビウス関数とかを導入するとより形式的に約数とかを扱えるようになるのかなあ
&amp;mdash; Niuez (@xiuez) January 22, 2020 概要 約数畳み込み メビウス関数 メビウスの反転公式(約数畳み込みの逆操作) 約数畳み込みと逆約数畳み込みのアルゴリズム $O(A \log{\log A})$ 最大公約数の扱い 集合の扱い AGC038C LCMsの解き方 ネタバレあるので気をつけてください</description></item><item><title>First</title><link>https://niuez.github.io/notes/first/</link><pubDate>Mon, 03 Feb 2020 17:19:14 +0900</pubDate><guid>https://niuez.github.io/notes/first/</guid><description>はじめまして
いつはてなブログが消えてもおかしくない気がするので, 僕のはてなブログからこっちに移してこようかなと考えてます.
テスト期間真っ最中なので春休みに入ったらやろうかな.
にう</description></item><item><title>Suffix Array と LCP と 文字列検索の実装をした</title><link>https://niuez.github.io/notes/entry/2019/12/16/203739/</link><pubDate>Mon, 16 Dec 2019 20:37:39 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/12/16/203739/</guid><description>この土日のメモです. SAとLCPのお気持ちをまとめたくなっただけ. 間違ってたらごめん
文字列アルゴの勉強する気が起きないたった一つの理由: Rolling Hash— νιυεζ (@xiuez) 2019年12月13日
これをやめたいので, 手始めにSuffix Arrayを使った文字列検索をやってみようかなというのが今回の主題
概要 SA-ISでSuffix Arrayを構築$ O(|S|)$ LCP配列の構築$ O(|S|)$ LCPによるSuffix同士のLCPをSparse Tableで構築$ O(|S| \log{|S|})$, クエリ$ O(1)$ Suffix Arrayの二分探索で文字列検索を$ O(|T| log{|S|})$ Suffix ArrayとLCPの二分探索で文字列検索を構築$ O(|S|)$, クエリ$ O(|T| + \log{|S|})$ の実装をやってみました.</description></item><item><title>動的木上の最小シュタイナー木をtoptreeで解く</title><link>https://niuez.github.io/notes/entry/2019/12/14/000036/</link><pubDate>Sat, 14 Dec 2019 00:00:36 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/12/14/000036/</guid><description>この記事は「データ構造とアルゴリズム Advent Calendar 2019」 14日目の記事です. 13日目は@ajalabさんのRun-Length FM-Index - koki, 15日目は@minaminaoさんのMerkle Patricia Tree まわりです.
toptreeとは toptreeは今年競プロ界隈で話題になった動的木を扱うデータ構造の一つです. link-cut treeも同じ動的木を扱うデータ構造ですが, 機能だけを見ればその完全上位互換です.
toptreeは, 木を動的に扱うデータ構造です. [cs/0310065] Maintaining Information in Fully-Dynamic Trees with Top Treesを読みました.</description></item><item><title>BFS Numbering</title><link>https://niuez.github.io/notes/entry/2019/10/05/002503/</link><pubDate>Sat, 05 Oct 2019 00:25:03 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/10/05/002503/</guid><description>僕が木上クエリコンで出題した問題で使った手法です.
No.899 γatheree - yukicoder
アルゴリズム 例
BFSを行って頂点に番号を順番に振っていきます.
1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 になります.</description></item><item><title>Toptree - Link &amp; Cut編</title><link>https://niuez.github.io/notes/entry/2019/08/05/114511/</link><pubDate>Mon, 05 Aug 2019 11:45:11 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/08/05/114511/</guid><description>Toptree 導入編 - niuez’s diary
引き続き, toptreeの解説をしていきます.
Link link(v, w): 頂点vとwを辺vwで結ぶをします.
場合分けが多すぎるんじゃ
が, vの次数が0, 1, 2以上で処理が変わり, またwの次数が0, 1, 2以上で処理が変わります. (ちなみに論文はどちらも次数2以上のときのことしか書いてない, 全部書けや)</description></item><item><title>Toptree 導入編</title><link>https://niuez.github.io/notes/entry/2019/08/04/191420/</link><pubDate>Sun, 04 Aug 2019 19:14:20 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/08/04/191420/</guid><description>みんな日本語記事を待っていたはず&amp;hellip;.!
toptreeがどんな感じで動いているのかを書いてみます
実装はここにあります
https://github.com/niuez/toptree-rust
0. toptree is なに toptreeはlink-cut treeの上位互換です. 木を切ったりつなげたり, パスのクエリを処理したり, 木上の二分探索ができたりします
今回はそのベースとなる構造の話です
1. Compress Rake 木をまとめる ここで言う木は, toptreeが表す木のことです. 曖昧にならないようにこのことをreal treeと呼ぶことにします.</description></item><item><title>top-tree実装体験木</title><link>https://niuez.github.io/notes/entry/2019/06/29/161729/</link><pubDate>Sat, 29 Jun 2019 16:17:29 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/06/29/161729/</guid><description>読者層が限定されすぎていませんか？
Link Cut Treeを書いたことがない人はこちら！
Link-Cut 木 - ei1333の日記
部分木クエリについてはこちら！
Link Cut Treeで部分木の情報を管理する - beet's soil
最遠点クエリについてはこちら！
Link-Cut木と最遠点クエリ - ei1333の日記</description></item><item><title>ダイクストラとポテンシャルのはなし</title><link>https://niuez.github.io/notes/entry/2019/03/04/142903/</link><pubDate>Mon, 04 Mar 2019 14:29:03 +0000</pubDate><guid>https://niuez.github.io/notes/entry/2019/03/04/142903/</guid><description>はじめまして, niuezといいます. 競プロを少ししています.
最近勉強したことのメモ書きをしておきます.
ダイクストラ法 ダイクストラ法(Dijkstra)は負の長さの無いグラフで始点からの最短距離を求めるアルゴリズムです.
具体的には
距離が未確定の頂点の中で一番小さいものを選び, 距離を確定させる. 選んだ頂点から距離が未確定の頂点に伸びる辺で, 未確定な距離をより短いものに更新する. を繰り返します. これを実装すると $O(N)$ですが, よく知られるダイクストラの計算量は $O((E+ V) \log E)$ です(heapとかを使う).</description></item></channel></rss>